ABAPZombie Guide to ABAP ‚Äì Parte 10 ‚Äì AT (NEW, FIRST, LAST)
Autor: Mauricio Cruz
Data: 15/02/2011 08:30

O Comando AT (loops de tabelas internas) √© um comando divertido e √∫til em diversos casos. Ele pode ser colocado dentro de LOOPs, e ele direciona a execu√ß√£o de acordo com algumas restri√ß√µes:
AT FIRST‚Ä¶ ENDAT:
Entra no bloco para executar algum processo no primeiro registro do LOOP.
AT LAST‚Ä¶ ENDAT:
Entra no bloco para executar algum processo no √∫ltimo registro do LOOP.
AT NEW (campo)‚Ä¶ ENDAT:
Entra no bloco sempre que o valor de (campo) mudar. (campo) deve ser um campo existente na estrutura usada no LOOP.
Por√©m, nem tudo √© simples na vida do ABAPer. Vejamos o c√≥digo:
REPORT zombie_at.

* Declara√ß√µes
*----------------------------------------
TYPES: BEGIN OF ty_mara,
        mtart TYPE mara-mtart,
        matnr TYPE mara-matnr,
       END OF ty_mara.

DATA: t_mara TYPE TABLE OF ty_mara.

DATA: wa_mara LIKE LINE OF t_mara.

DATA: l_matnr TYPE mara-matnr,
      l_mtart TYPE mara-matnr.

**-----------------------------------------------------------------
* START-OF-SELECTION
*------------------------------------------------------------------
START-OF-SELECTION.

* Estou limitando o select para 10 linhas, para ficar mais f√°cil de
* entender :D
  SELECT mtart matnr
    FROM mara
    INTO TABLE t_mara
    UP TO 10 ROWS.

* Ordenando a tabela para n√£o ferrar com o AT NEW!
 SORT t_mara BY mtart matnr.

* E a magia tem in√≠cio:
 LOOP AT t_mara INTO wa_mara.

*   Aqui todos os campos CHAR v√£o virar '*' e os outros campos ir√£o
*   ficar vazios. √â, nem tudo √© lindo na vida do ABAPer...

*   O jeito √© fazer a atribui√ß√£o em vari√°veis locais, work areas, etc
    l_matnr = wa_mara-matnr.
    l_mtart = wa_mara-mtart.

    AT FIRST.
      WRITE: 'First! - -Linha com **',
             / wa_mara-matnr, space, wa_mara-mtart.
      WRITE: / 'Print correto dos valores:',
             / l_matnr, space, l_mtart.
      SKIP 1.
    ENDAT.

*   Pelo menos aqui o comando n√£o atrapalha os valores da Work Area.
*   o processamento vai parar nesse bloco sempre que o valor de mtart
*   mudar, portanto mantenham o SORT correto crian√ßas!
    AT NEW mtart.
      WRITE: / 'New one!',
             / wa_mara-mtart.
    ENDAT.

*   O AT LAST funciona igual ao first. Triste, eu sei!
    AT LAST.
      SKIP 1.
      WRITE: / 'Last - Print com *',
       / wa_mara-matnr, space, wa_mara-mtart.
    ENDAT.

 ENDLOOP.
Pelo exemplo deu para ver que existem algumas restri√ß√µes:
Os comandos
AT LAST
e
AT FIRST
sempre ir√£o ‚Äúsumir‚Äù com os valores da WORK AREA. Isso √© um restri√ß√£o do sistema, e voc√™ pode usar o mesmo esquema que eu fiz no c√≥digo acima para pegar os valores da Work Area (atribuir os valores em vari√°veis locais).
O comando
AT NEW
sempre verifica se o campo utilizado no
AT NEW
muda de acordo com a sequ√™ncia da tabela do LOOP. Mas aqui tem um pequeno
gato
: ele tamb√©m verifica se os campos √† esquerda mudaram de valor. Se eles mudarem, ele tamb√©m ir√° entrar no la√ßo! Veja:
REPORT zombie_at.

* Declara√ß√µes
*----------------------------------------
DATA: t_mara TYPE TABLE OF mara.

DATA: wa_mara LIKE LINE OF t_mara.

START-OF-SELECTION.

* Estou limitando o select para 10 linhas, para ficar mais f√°cil de
* entender :D
  SELECT *
    FROM mara
    INTO TABLE t_mara
    UP TO 10 ROWS.

* Ordenando a tabela para n√£o ferrar com o AT NEW!
 SORT t_mara BY mtart matnr.

* E magia tem in√≠cio:
 LOOP AT t_mara INTO wa_mara.

*   Apesar do SORT estar correto, ele ir√° imprimir as 10 linhas (ou
*   menos), porque o valor do campo MATNR que est√° a esquerda do campo
*   MTART sempre muda. Se voc√™ notar bem, no exemplo anterior eu
*   declarei um TYPES com o campo MTART antes do MATNR, para evitar
*   este problema.
    AT NEW mtart.
      WRITE: / 'New one!',
             / wa_mara-mtart.
    ENDAT.

 ENDLOOP.
O AT √© legal, se usado com cuidado. √â muito f√°cil se perder com o AT NEW por causa do
gato
que eu citei. Voc√™ pode destruir um programa que j√° funciona s√≥ por colocar um campo novo √† esquerda do campo usado no AT NEW, por exemplo. Portanto, use com ‚Äúcarinho‚Äù üòÄ
Abra√ßos!



Coment√°rios:
Carlos (27/06/2016 18:25): Boa tarde, pessoal, No exemplo acima, mostra o loop com esse comando que funciona assim LOOP AT it_spfli INTO wa_spfli. Mas eu vi comando onde o loop est√° assim LOOP AT t_sairport. A diferen√ßa √© que eu n√£o consegui fazer funcionar. Algu√©m tem o exemplo desse comando LOOP AT t_sairport.?
Marcelo (17/08/2012 09:51): Valeu pelo post, Mas uma duvida, algu√©m entende pq o programa se perde quando usamos AT NEW em um LOOP contendo WHERE ?? Marcelo
  Paolo (27/05/2014 11:54): Ol√° Marcelo, eu n√£o cheguei a testar um LOOP WHERE para este caso, mas, se o problema for o WHERE, acredito que um LOOP BIN√ÅRIO resolveria este problema. atte.
  Paolo (27/05/2014 11:54): Ol√° Marcelo, eu n√£o cheguei a testar um LOOP WHERE para este caso, mas, se o problema for o WHERE, acredito que um LOOP BIN√ÅRIO resolveria este problema. atte.
Felipe Tieppo (26/04/2012 11:39): Uma outra forma contornar o ‚Äúproblema‚Äù do AT LAST e AT FIRST √© usar um field symbol.