ABAPZombie Guide to ABAP ‚Äì Parte 28 ‚Äì COLLECT
Autor: Mauricio Cruz
Data: 07/12/2011 14:16

E c√° estou eu, continuando essa saga que n√£o tem um post novo desde Agosto. Eu n√£o desisti, e n√£o desistirei
jamais
! üòà
Enfim, hoje vou explicar um comando que deixa ABAPers Jrs maravilhados pelo mundo todo, o
COLLECT!
Eu resumo o funcionamento desse comando da seguinte forma:
se √© valor, soma essa parada.
Fim do post de hoje galera!
üôÑ
Mas a id√©ia √© essa mesma: se voc√™ utilizar um COLLECT na hora de adicionar valores de uma work area para a sua tabela interna, o sistema vai verificar se existe alguma outra entrada com a mesma chave prim√°ria na tabela.
Se tiver,
ele vai somar todos os campos com valores, ao inv√©s de duplicar a linha.
Se n√£o tiver,
ele cria uma nova entrada.
Vamos ver isso funcionando na pr√°tica:
REPORT  zombie_collect.

TYPES: BEGIN OF ty_val,
         nome TYPE char10,
         sal  TYPE i,
       END OF ty_val.

DATA: t_val  TYPE SORTED TABLE OF ty_val WITH UNIQUE KEY nome,
      wa_val LIKE LINE OF t_val.

wa_val-nome = 'Zombie1'.
wa_val-sal  = 123.
COLLECT wa_val INTO t_val.

wa_val-nome = 'Zombie2'.
wa_val-sal  = 321.
COLLECT wa_val INTO t_val.

wa_val-nome = 'Zombie1'.
wa_val-sal  = 321.
COLLECT wa_val INTO t_val.
Esse √© o funcionamento b√°sico. Mas como toda boa opera√ß√£o com tabelas internas no ABAP, o COLLECT funciona de maneira diferente para cada tipo de tabela. No caso acima, se tentarmos adicionar um campo n√£o num√©rico
fora
da chave prim√°ria, o c√≥digo n√£o compila por conta do COLLECT. Vejam:
REPORT  zombie_collect.

TYPES: BEGIN OF ty_val,
         nome  TYPE char10,
         cargo TYPE char10,
         sal   TYPE i,
       END OF ty_val.

DATA: t_val  TYPE SORTED TABLE OF ty_val WITH UNIQUE KEY nome,
      wa_val LIKE LINE OF t_val.

wa_val-nome  = 'Zombie1'.
wa_val-cargo = 'Gerente'.
wa_val-sal   = 123.
COLLECT wa_val INTO t_val. "N√£o Compila!!!
A busca pela linha feita pelo COLLECT para tabelas SORTED √© sempre feita com um
algoritmo de busca bin√°ria
. Ah, e o COLLECT tamb√©m n√£o destr√≥i a ordena√ß√£o da tabela, caso o registro n√£o exista e ele tenha que criar uma nova entrada. Divertido, n√£o? üôÇ
O funcionamento do COLLECT para SORTED e HASHED tables √© praticamente o mesmo, a √∫nica diferen√ßa √© que o sistema utiliza o algoritmo hash para fazer a busca na tabela interna, ao inv√©s de fazer a busca bin√°ria.
Maaaas, e se n√£o for tabela SORTED nem HASHED?
REPORT  zombie_collect.

TYPES: BEGIN OF ty_val,
         nome  TYPE char10,
         cargo TYPE char10,
         sal   TYPE i,
       END OF ty_val.

* Lembrando que quando existe s√≥ o "TABLE", o sistema
* assume que a tabela √© uma STANDARD TABLE automaticamente
DATA: t_val  TYPE TABLE OF ty_val,
      wa_val LIKE LINE OF t_val.

wa_val-nome  = 'Zombie1'.
wa_val-cargo = 'Gerente'.
wa_val-sal   = 123.
COLLECT wa_val INTO t_val.

wa_val-nome = 'Zombie2'.
wa_val-cargo = 'Diretor'.
wa_val-sal  = 321.
COLLECT wa_val INTO t_val.

wa_val-nome = 'Zombie1'.
wa_val-cargo = 'Func'.
wa_val-sal  = 321.
COLLECT wa_val INTO t_val.
Notem que esse √© o mesmo exemplo do COLLECT com tabela SORTED que n√£o compila. Mas no caso acima, o sistema vai criar 3 linhas! Sim, porque para tabelas STANDARDs sem chave declarada, o COLLECT vai comparar TODOS os campos n√£o num√©ricos para saber se pode ou n√£o somar. No exemplo acima, troque todos os cargos para ‚ÄúDiretor‚Äù e teste novamente üôÇ
Se a entrada n√£o existir, o COLLECT vai ter o mesmo efeito do APPEND em STANDARD TABLES.
Uma curiosidade legal sobre o COLLECT em STANDARD TABLES: o sistema monta um ‚Äúcache‚Äù da tabela em mem√≥ria organizada por um algoritmo hash, sempre que ela √© preenchida com o COLLECT. Isso faz o acesso posterior pelo COLLECT ficar bem r√°pido. Por√©m, se qualquer outro comando como INSERT ou APPEND alterarem a tabela, esse ‚Äúcache‚Äù vai para o espa√ßo, e o sistema faz a busca de forma linear caso algum COLLECT seja novamente utilizado.
Meio enrolado n√©? üòõ Eu vou fazer um post explicando somente Hash Tables em breve!
Divirta-se utilizando o COLLECT, e sofra quando voc√™ descobrir uma diferen√ßa no valor em um campo de uma tabela com 34 campos de valores ocasionada aparentemente pelo COLLECT. Lembre-se que a culpa nunca √© do comando üòÄ
Abra√ßos!



Coment√°rios:
Gustavo B√ºchle (23/11/2016 19:25): Valeu pessoal!!!!
Eduardo Pereira (01/03/2016 15:31): Excelente post!!! N√£o sabia dessas restri√ß√µes do Collect. Ajudou bastante, parab√©ns!
Leonardo (09/12/2011 12:37): Sempre muito bom os posts! Parab√©ns. Este comando auxilia muito para n√£o fazer as somas na m√£o. Abs