Processamento em Paralelo utilizando RFC Ass√≠ncrona
Autor: Daiane Medeiros
Data: 12/03/2012 15:39

Demorou, mas chegou! Meu post inaugural no ABAP Zombie! Vou come√ßar falando um pouco sobre processamento paralelo com RFC Ass√≠ncrona. Hein???
O processamento em paralelo (ou paralelismo) n√£o √© um conceito novo, mas √© pouco utilizado para melhoria de performance. Por qu√™?
Em alguns casos podemos utilizar mais de uma sess√£o (ou task) dispon√≠vel, mas geralmente utilizamos apenas uma delas. √â como se uma transportadora contasse apenas com um caminh√£o para levar seus produtos, quando h√° uma frota inteira de caminh√µes que podem ser utilizados.
N√£o √© s√≥ isso, a maioria dos sistemas conta com mais de um servidor de aplica√ß√£o com uma s√©rie de sess√µes dispon√≠veis. Ent√£o, o que estamos esperando?
Utilizar processamento paralelo ou n√£o, eis a quest√£o!
Neste post vou mostrar um exemplo pr√°tico utilizando RFC Ass√≠ncrona. Vamos tentar equilibrar o trabalho do programa com base no n√∫mero de dados informados na tela de sele√ß√£o e nas sess√µes dispon√≠veis nos servidores de aplica√ß√£o. Por √∫ltimo, vamos analisar o tempo de execu√ß√£o do programa e comparar a execu√ß√£o utilizando uma √∫nica sess√£o. Ent√£o, vamos l√°!
REPORT  zppbap_rfc_assincrona.
**********************************************************************
* VARI√ÅVEIS GLOBAIS (V_...)                                          *
**********************************************************************
DATA: v_tasks        TYPE i,
      v_task_id      TYPE numc2,
      v_task_count   TYPE i,
      v_task_ativa   TYPE i.

**********************************************************************
* TABELA INTERNA (T_...)                                             *
**********************************************************************
DATA: t_bseg      TYPE TABLE OF bseg,
      t_bseg_aux  TYPE TABLE OF bseg.

**********************************************************************
* TABELA                                                             *
**********************************************************************
TABLES: bseg.

**********************************************************************
* PAR√ÇMETROS DE TELA:                                                *
*   SELECT OPTIONS (S_...)                                           *
*   PARAMETERS     (P_...)                                           *
**********************************************************************
SELECTION-SCREEN BEGIN OF BLOCK b1 WITH FRAME.

SELECT-OPTIONS: s_gjahr FOR bseg-gjahr OBLIGATORY NO INTERVALS. "Ano
* Obs. Estou utilizando apenas como chave o campo GJAHR, pois o ambiente
* que estou fazendo testes n√£o possui muitos registros

SELECTION-SCREEN END OF BLOCK b1.

**********************************************************************
* START-OF-SELECTION                                                 *
**********************************************************************
START-OF-SELECTION.
  DATA: wa_gjahr LIKE LINE OF s_gjahr.

* Obter o n√∫mero de sess√µes dispon√≠veis
  CALL FUNCTION 'SPBT_INITIALIZE'
    IMPORTING
      free_pbt_wps                   = v_tasks
    EXCEPTIONS
      invalid_group_name             = 1
      internal_error                 = 2
      pbt_env_already_initialized    = 3
      currently_no_resources_avail   = 4
      no_pbt_resources_found         = 5
      cant_init_different_pbt_groups = 6
      OTHERS                         = 7.

  IF sy-subrc <> 0.
*** Mensagem de erro
    LEAVE LIST-PROCESSING.
  ENDIF.

* Para cada ano informado na tela de sele√ß√£o, ser√° chamada a RFC
  LOOP AT s_gjahr INTO wa_gjahr.

* Como n√£o sabemos a quantidade de registros, devemos controlar quantas sess√µes ser√£o geradas
    DO.

* Incrementar ao contador de sess√µes ativas
      IF sy-subrc IS INITIAL.
        ADD 1 TO v_task_ativa.
      ENDIF.

* Verificar se o n√∫mero de sess√µes ativas est√° dentro do limite
      IF v_task_ativa <= v_tasks.

* Cada sess√£o dever√° ter um ID √∫nico
        ADD 1 TO v_task_id.

* Chamar a RFC em uma nova sess√£o
        CALL FUNCTION 'Z_RFC_ASSINC'
          STARTING NEW TASK v_task_id
          DESTINATION IN GROUP DEFAULT
          PERFORMING update_order ON END OF TASK
          EXPORTING
            i_gjahr = wa_gjahr-low
          EXCEPTIONS
            OTHERS  = 1.

        IF sy-subrc <> 0.
* Se a RFC falhar, vamos tentar novamente e diminuir o n√∫mero de sess√µes ativas. Cuidado para n√£o entrar
* em loop infinito!!
          SUBTRACT 1 FROM v_task_ativa.
        ELSE.
          EXIT.
        ENDIF.
      ELSE.
        SUBTRACT 1 FROM v_task_ativa.
      ENDIF.
    ENDDO.
  ENDLOOP.

  IF sy-subrc IS INITIAL.
* Esperar at√© que todas as sess√µes sejam finalizadas. O n√∫mero √© decrementado na subrtoina abaixo
* e incrementado quando a RFC √© chamada.
    WAIT UNTIL v_task_ativa = 0.

*** Neste ponto voc√™ poder√° utilizar os resultados retornados da RFC para continuar a l√≥gica do programa

  ENDIF.

**********************************************************************
* SUBROTINA                                                          *
**********************************************************************
FORM update_order USING name.

* Obter os resultados da RFC
  RECEIVE RESULTS FROM FUNCTION 'Z_RFC_ASSINC'
     TABLES
      t_bseg       = t_bseg_aux.

  APPEND LINES OF t_bseg_aux TO t_bseg.

  SUBTRACT 1 FROM v_task_ativa.

ENDFORM.                    " UPDATE_ORDER
An√°lise do Tempo de Execu√ß√£o
√önica sess√£o:
Utilizando Processamento em Paralelo:
Atrav√©s da transa√ß√£o SE30, podemos analisar o tempo de execu√ß√£o de cada programa. No meu exemplo, eu consegui uma melhoria de 18% do tempo que levou para execut√°-lo em uma √∫nica sess√£o.
Mas aten√ß√£o!!!
Antes de come√ßar a implementar, devemos nos certificar que o processamento em paralelo deve ser
logicamente independente
. Como assim? Explico: cada processo n√£o pode depender de outros dados que est√£o sendo processados paralelamente, pois n√£o temos como garantir que os dados ser√£o processados em uma ordem espec√≠fica.
O programa principal n√£o pode mudar de sess√£o depois de chamar a RFC Ass√≠ncrona, ou seja, voc√™ n√£o deve usar SUBMIT ou CALL TRANSACTION depois de usar CALL FUNCTION STARTING NEW TASK.
N√£o √© recomendado utilizar COMMIT dentro da RFC Ass√≠ncrona, pois poderia entrar em conflito com a sess√£o em que o programa principal est√° sendo executado.
√â isso a√≠ zombies, espero que tenham gostado, at√© uma pr√≥xima! üòâ



Coment√°rios:
Gilson (20/01/2015 09:14): Ol√° pessoal! Utilizei recentemente este exemplo no meu programa e tenho uma d√∫vida aqui‚Ä¶ Quando o programa atinge todas as sess√µes ele cai no ELSE e decrementa 1 na vari√°vel v_task_ativa. Por√©m, volta para o in√≠cio do Do e incrementa novamente e fica nesse Loop infinito por que s√≥ ir√° chamar o perform UPDATE_ORDER para subtrair a vari√°vel v_task_ativa quando sair do Loop. Isso √© normal? Ou estou fazendo algo errado? :S Abs.
  Daiane Zigiotto (05/02/2015 10:26): Oi Gilson! Desculpa a demora üôÅ Muito bem observado, tinha um erro no c√≥digo üòõ Coloquei uma valida√ß√£o de sy-subrc, assim nos casos de erro, n√£o incrementa o n√∫mero de tasks, sen√£o vira um loop infinito. Acho que fazendo isso j√° soluciona o problema. Vou arrumar o c√≥digo no post, valeu pelo coment√°rio!
    Robson (24/09/2017 15:46): Segundo meu teste, se tiver menos tasks dispon√≠veis que o n√∫mero de incrementos do LOOP vai ficar em loop infinito, pois n√£o vai ocorrer a chamada da FORM update_order para decrementar o n√∫meros de tasks ativas. Pelo que estou observando, s√≥ vai chamar este FORM se encontrar um WAIT, faz sentido? Ex.: N√∫mero de tasks dispon√≠veis: 2 N√∫mero de anos a serem processados: 3 Obrigado.
    Robson (24/09/2017 15:46): Segundo meu teste, se tiver menos tasks dispon√≠veis que o n√∫mero de incrementos do LOOP vai ficar em loop infinito, pois n√£o vai ocorrer a chamada da FORM update_order para decrementar o n√∫meros de tasks ativas. Pelo que estou observando, s√≥ vai chamar este FORM se encontrar um WAIT, faz sentido? Ex.: N√∫mero de tasks dispon√≠veis: 2 N√∫mero de anos a serem processados: 3 Obrigado.
  Daiane Zigiotto (05/02/2015 10:26): Oi Gilson! Desculpa a demora üôÅ Muito bem observado, tinha um erro no c√≥digo üòõ Coloquei uma valida√ß√£o de sy-subrc, assim nos casos de erro, n√£o incrementa o n√∫mero de tasks, sen√£o vira um loop infinito. Acho que fazendo isso j√° soluciona o problema. Vou arrumar o c√≥digo no post, valeu pelo coment√°rio!
    Robson (24/09/2017 15:46): Segundo meu teste, se tiver menos tasks dispon√≠veis que o n√∫mero de incrementos do LOOP vai ficar em loop infinito, pois n√£o vai ocorrer a chamada da FORM update_order para decrementar o n√∫meros de tasks ativas. Pelo que estou observando, s√≥ vai chamar este FORM se encontrar um WAIT, faz sentido? Ex.: N√∫mero de tasks dispon√≠veis: 2 N√∫mero de anos a serem processados: 3 Obrigado.
    Robson (24/09/2017 15:46): Segundo meu teste, se tiver menos tasks dispon√≠veis que o n√∫mero de incrementos do LOOP vai ficar em loop infinito, pois n√£o vai ocorrer a chamada da FORM update_order para decrementar o n√∫meros de tasks ativas. Pelo que estou observando, s√≥ vai chamar este FORM se encontrar um WAIT, faz sentido? Ex.: N√∫mero de tasks dispon√≠veis: 2 N√∫mero de anos a serem processados: 3 Obrigado.
Daniel Jesus (17/02/2014 11:55): Mauricio, as fun√ß√µes  ficam mesmo dialogo usando esta t√©cnica. =/ http://help.sap.com/saphelp_nw04/helpdata/EN/22/0425c6488911d189490000e829fbbd/content.htm
Tatiana (13/06/2013 09:29): Ol√° Daiane, obrigada pelo retorno! Bom, j√° utilizamos este recurso.. üôÅ De fato ajuda, mas n√£o resolve o problema. A nossa quest√£o aqui √© o acesso a tabelas muito grandes, sem arquivamento. A outra id√©ia que surgiu foi disparar v√°rios JOBs (pequenos JOBs, assim como √© feita a chamada da CALL FUNCTION). O que estou tentando ver agora √© como encadear as execu√ß√µes posteriores. Tenho 5 processamentos encadeados, dentro do mesmo programa. O primeiro √© que √© problem√°tico, e foi neste que trabalhamos o paralelismo. Os pr√≥ximos 4 dependem da conclus√£o deste primeiro. Na solu√ß√£o com paralelismo, o tempode execu√ß√£o caiu de 2 horas para 20 min. Gostaria muito de continuar com este tempo‚Ä¶ rsrsrsr‚Ä¶
Tatiana (13/06/2013 08:31): Oi Mauricio, obrigada pelo retorno. Bom, hoje meu processamento est√° sendo executado em background sem cancelar. Por√©m tive que aumentar um pouco o n√∫mero de se√ß√µes a serem abertas. Pois com um n√∫mero menor est√° dando TIME OUT.
  Daiane Zigiotto (13/06/2013 09:18): Ol√° Tatiana, obrigada pelo seu coment√°rio! Talvez o que pode te ajudar a definir a n√∫mero de tasks √© utilizando a fun√ß√£o SPBT_INITIALIZE onde retorna a quantidade de tasks livres (FREE_PBT_WPS) e a quantidade m√°xima de tasks (MAX_PBT_WPS). Abs!
  Daiane Zigiotto (13/06/2013 09:18): Ol√° Tatiana, obrigada pelo seu coment√°rio! Talvez o que pode te ajudar a definir a n√∫mero de tasks √© utilizando a fun√ß√£o SPBT_INITIALIZE onde retorna a quantidade de tasks livres (FREE_PBT_WPS) e a quantidade m√°xima de tasks (MAX_PBT_WPS). Abs!
Tatiana (12/06/2013 16:56): Ol√°, boa tarde! Tenho uma d√∫vida: √© poss√≠vel este processamento ser executado em background? Pelo que percebi, as se√ß√µes s√£o abertas ‚Äúonline‚Äù mesmo quando executo em background. Com isso, se for um processamento muito pesado, posso ter o risco de TIME OUT em alguma destas se√ß√µes.
  Mauricio Cruz (13/06/2013 08:19): Olha, at√© onde eu sei essas novas tasks tamb√©m s√£o executadas em background‚Ä¶ Particularmente, sempre otimizei programas massivos que s√£o executados em background com paralelismo (starting new task) e nunca tive problemas. Abs!
  Mauricio Cruz (13/06/2013 08:19): Olha, at√© onde eu sei essas novas tasks tamb√©m s√£o executadas em background‚Ä¶ Particularmente, sempre otimizei programas massivos que s√£o executados em background com paralelismo (starting new task) e nunca tive problemas. Abs!
Navier Stokes (26/09/2012 22:24): achei um lance no link http://help.sap.com/abapdocu_70/en/ABAPCALL_FUNCTION_STARTING.htm da um search em ‚Äú‚Ä¶must not exceed certain threshold values. ‚Äù tem limite de di√°logo nisso ?? Esse problema √© disso ???
  Mauricio Cruz (13/06/2013 08:21): Sim, por isso que voc√™ tem que usar a fun√ß√£o SPBT_INITIALIZE para descobrir quantas tasks o seu sistema tem aberto, antes de implementar o paralelismo.
  Mauricio Cruz (13/06/2013 08:21): Sim, por isso que voc√™ tem que usar a fun√ß√£o SPBT_INITIALIZE para descobrir quantas tasks o seu sistema tem aberto, antes de implementar o paralelismo.
Navier Stokes (26/09/2012 22:21): o ponto de cancelamento foi na fun√ßao AC_FLUSH_CALL_INTERNAL‚Äù.
Navier Stokes (26/09/2012 22:19): seguinte tive um dump depois de passar algumas vezes : segue o dump RPERF_ILLEGAL_STATEMENT TEXTO BREVE STATEMENT ‚ÄúCALL FUNCTION .. DESTINATION/STARTING NEW TASK /IN BACKGROUND TASK‚Äù SAPLOLEA The program was probably‚Ä¶ Function modules called CONVERSION_EXIT_xxxxx_INPUT/OUTPUT or USER_EXIT_xxxxx_INPUT. etc etc etc .. algu√©m por favor me ajuda ? abracos
Deocleciano Maranh√£o Neto (29/08/2012 11:41): O c√≥digo que enviei n√£o ficou formatado ‚Ä¶ acho que n√£o inseri a tag corretamente !!!! Ser√° que ainda d√° pra editar? (Deletar Coment√°rio)
Deocleciano Maranh√£o Neto (27/08/2012 16:07): Gostei muito desse post, pois paralelismo √© um assunto muito interessante em qualquer linguagem !!! S√≥ fiquei triste pois  o exemplo n√£o mostra v√°rias entradas para ilustrar melhor o paralelismo. Eu fiz alguns ajustes no c√≥digo para tentar testar ao meu gosto üôÇ ( A RFC deve ser feita em outro ambiente!) REPORT  znto_assincrona_sbook.

**********************************************************************
* VARI√ÅVEIS GLOBAIS (V_...)                                          *
**********************************************************************
DATA: v_tasks_sist        TYPE i,
      v_max_tasks    TYPE i,
      v_task_id      TYPE numc2,
      v_task_count   TYPE i,
      v_task_ativa   TYPE i.

**********************************************************************
* TABELA INTERNA (T_...)                                             *
**********************************************************************
DATA: t_sbook      TYPE TABLE OF sbook,
      t_sbook_aux  TYPE TABLE OF sbook,
      t_carrid    TYPE TABLE OF zes_carrid.

**********************************************************************
* TABELA                                                             *
**********************************************************************
TABLES: sbook.

**********************************************************************
* PAR√ÇMETROS DE TELA:                                                *
*   SELECT OPTIONS (S_...)                                           *
*   PARAMETERS     (P_...)                                           *
**********************************************************************
SELECTION-SCREEN BEGIN OF BLOCK b1 WITH FRAME.

SELECT-OPTIONS: s_carrid FOR sbook-carrid OBLIGATORY NO INTERVALS. "Ano
*SELECT-OPTIONS: s_carrid FOR sbook-carrid OBLIGATORY no INTERVALS. "Ano
* Obs. Estou utilizando apenas como chave o campo carrid, pois o ambiente
* que estou fazendo testes n√£o possui muitos registros

SELECTION-SCREEN END OF BLOCK b1.

**********************************************************************
* START-OF-SELECTION                                                 *
**********************************************************************
START-OF-SELECTION.
  DATA: wa_carrid LIKE LINE OF s_carrid,
        wa_carrid TYPE zes_carrid,
        vl_num_registros TYPE i ,
        vl_num_linhas TYPE i ,
        vl_dados_task TYPE i ,
        vl_lin_carrid TYPE i ,
        vl_num TYPE char10 ,
        vl_mensagem   TYPE char80.

* Obter o n√∫mero de sess√µes dispon√≠veis
  CALL FUNCTION 'SPBT_INITIALIZE'
    IMPORTING
      free_pbt_wps                   = v_tasks_sist
      max_pbt_wps                    = v_max_tasks
    EXCEPTIONS
      invalid_group_name             = 1
      internal_error                 = 2
      pbt_env_already_initialized    = 3
      currently_no_resources_avail   = 4
      no_pbt_resources_found         = 5
      cant_init_different_pbt_groups = 6
      OTHERS                         = 7.

  IF sy-subrc  0.
*** Mensagem de erro
    LEAVE LIST-PROCESSING.
  ENDIF.

*  v_tasks_sist = 2.

  DESCRIBE TABLE s_carrid LINES vl_num_linhas.

  vl_dados_task = vl_num_linhas / v_tasks_sist.

  LOOP AT s_carrid INTO wa_carrid.

    wa_carrid-i_carrid = wa_carrid-low.

    APPEND wa_carrid TO t_carrid.

    DESCRIBE TABLE t_carrid LINES vl_lin_carrid.
* Verifica se tabela esta com x dados para chamar nova RFC
    IF vl_dados_task = vl_lin_carrid  .

      PERFORM znova_task.

      FREE t_carrid.
*
    ELSEIF ( vl_dados_task > vl_lin_carrid AND
             sy-tabix = vl_num_linhas ).
      PERFORM znova_task.

    ENDIF.
  ENDLOOP.

  IF sy-subrc IS INITIAL.
* Esperar at√© que todas as sess√µes sejam finalizadas. O n√∫mero √© decrementado na subrtoina abaixo
* e incrementado quando a RFC √© chamada.
    WAIT UNTIL v_task_ativa = 0.

*** Neste ponto voc√™ poder√° utilizar os resultados retornados da RFC para continuar a l√≥gica do programa
    DESCRIBE TABLE t_sbook LINES vl_num_registros.

    WRITE: vl_num_registros TO vl_num.


    CONCATENATE 'Tabela com ' vl_num ' registros' INTO vl_mensagem.

    WRITE :/ vl_mensagem.
  ENDIF.

**********************************************************************
* SUBROTINA                                                          *
**********************************************************************
FORM update_order USING name.

* Obter os resultados da RFC
  RECEIVE RESULTS FROM FUNCTION 'Z_RFC_ASSINC_SBOOK'
*     TABLES
*      t_sbook       = t_sbook_aux.
     IMPORTING
       t_sbook     = t_sbook_aux.

  APPEND LINES OF t_sbook_aux TO t_sbook.

  SUBTRACT 1 FROM v_task_ativa.

ENDFORM.                    " UPDATE_ORDER

*&---------------------------------------------------------------------*
*&      Form  ZNOVA_TASK
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM znova_task .
*     Como n√£o sabemos a quantidade de registros, devemos controlar quantas sess√µes ser√£o geradas

*     Incrementar ao contador de sess√µes ativas
  ADD 1 TO v_task_ativa.

*     Verificar se o n√∫mero de sess√µes ativas est√° dentro do limite
  IF v_task_ativa <= v_tasks_sist.

*     Cada sess√£o dever√° ter um ID √∫nico
    ADD 1 TO v_task_id.

*     Chamar a RFC em uma nova sess√£o
    CALL FUNCTION 'Z_RFC_ASSINC_SBOOK'
      STARTING NEW TASK v_task_id
*              DESTINATION IN GROUP DEFAULT
      DESTINATION 'nome_do_destino'
      PERFORMING update_order ON END OF TASK
      EXPORTING
        t_carrid = t_carrid
      EXCEPTIONS
        OTHERS  = 1.

    IF sy-subrc  0.
*     Se a RFC falhar, vamos tentar novamente e diminuir o n√∫mero de sess√µes ativas. Cuidado para n√£o entrar
*     em loop infinito!!
      SUBTRACT 1 FROM v_task_ativa.
    ELSE.
      EXIT.
    ENDIF.

    FREE t_carrid.
    CLEAR vl_lin_carrid.
  ELSE.
    SUBTRACT 1 FROM v_task_ativa.
  ENDIF.
*        ENDDO.
ENDFORM.                    " ZNOVA_TASK
Jesus (04/06/2012 09:35): P√¥ eu gostei. T√° simples e objetivo. O resto √© s√≥ pesquisar, mas a base ta aqui.
Bruno (22/05/2012 10:26): A ideia √© muito boa, mas o exemplo foi muito mauzinho‚Ä¶ As melhores situa√ß√µes para usar paralelismo s√£o processos que usem principalmente capacidade de processamento, e n√£o base de dados. Este exemplo feito com um programa de computa√ß√£o matem√°tica tipo um algoritmo para calcular uma ra√≠z quadrada ou algo desse g√©nero os resultados seriam muito melhores. 18% quase n√£o justifica a perda de tempo a implementar o paralelismo.
  Daiane Zigiotto (22/05/2012 19:41): Ol√° Bruno, A id√©ia do Paralelismo Ass√≠ncrono √© dividir a carga do programa em pacotes e que os dados executados em paralelo sejam independentes entre si, e isso pode se aplicar a uma sele√ß√£o de dados que usa uma tabela no FOR ALL ENTRIES com MUITOS registros, por exemplo, pois dessa forma voc√™ poder√° melhorar (e muito) a performance do seu programa, e √© justamente sobre isso que eu queria falar neste post‚Ä¶ O seu exemplo pode ser aplicado no conceito de RFC Transacional (usando CALL FUNCTION‚Ä¶ IN BACKGROUND TASK), pois √© necess√°rio chamar apenas um √∫nico processo separadamente. Infelizmente, no ambiente de testes que eu usei, existiam poucos registros ent√£o eu tive que me virar com o que eu tinha! 18% n√£o parece ser muita coisa, mas isso varia de acordo com cada ambiente e com a quantidade de dados. Abs,
  Daiane Zigiotto (22/05/2012 19:41): Ol√° Bruno, A id√©ia do Paralelismo Ass√≠ncrono √© dividir a carga do programa em pacotes e que os dados executados em paralelo sejam independentes entre si, e isso pode se aplicar a uma sele√ß√£o de dados que usa uma tabela no FOR ALL ENTRIES com MUITOS registros, por exemplo, pois dessa forma voc√™ poder√° melhorar (e muito) a performance do seu programa, e √© justamente sobre isso que eu queria falar neste post‚Ä¶ O seu exemplo pode ser aplicado no conceito de RFC Transacional (usando CALL FUNCTION‚Ä¶ IN BACKGROUND TASK), pois √© necess√°rio chamar apenas um √∫nico processo separadamente. Infelizmente, no ambiente de testes que eu usei, existiam poucos registros ent√£o eu tive que me virar com o que eu tinha! 18% n√£o parece ser muita coisa, mas isso varia de acordo com cada ambiente e com a quantidade de dados. Abs,
Antonio (28/03/2012 16:56): Cade a estrutura da Function Z_RFC_ASSINC?
  Daiane Zigiotto (28/03/2012 17:10): Oi Antonio! A Z_RFC_ASSINC faz uma sele√ß√£o na tabela BSEG utilizando como condi√ß√£o o valor do par√¢metro de importa√ß√£o I_GJAHR e depois retorna os registros na tabela T_BSEG. Era essa sua d√∫vida? Abs,
    Mauricio Cruz (29/03/2012 09:06): Ahm, a Daiane explicou e tal, mas a estrutura da RFC n√£o importa muito para o exemplo. Tanto faz quais s√£o os par√¢metros, o funcionamento do paralelismo, que √© o importante do post, √© o mesmo. Ah, e para quem n√£o sabe: quando falamos ‚ÄúRFC‚Äù, estamos falando de uma fun√ß√£o criada pela SE37/SE80 (e derivados do leite), mas que na primeira aba de caracter√≠sticas deve ter a op√ß√£o ‚Äúm√≥dulo de fun√ß√£o remota‚Äù marcada.
    Mauricio Cruz (29/03/2012 09:06): Ahm, a Daiane explicou e tal, mas a estrutura da RFC n√£o importa muito para o exemplo. Tanto faz quais s√£o os par√¢metros, o funcionamento do paralelismo, que √© o importante do post, √© o mesmo. Ah, e para quem n√£o sabe: quando falamos ‚ÄúRFC‚Äù, estamos falando de uma fun√ß√£o criada pela SE37/SE80 (e derivados do leite), mas que na primeira aba de caracter√≠sticas deve ter a op√ß√£o ‚Äúm√≥dulo de fun√ß√£o remota‚Äù marcada.
  Daiane Zigiotto (28/03/2012 17:10): Oi Antonio! A Z_RFC_ASSINC faz uma sele√ß√£o na tabela BSEG utilizando como condi√ß√£o o valor do par√¢metro de importa√ß√£o I_GJAHR e depois retorna os registros na tabela T_BSEG. Era essa sua d√∫vida? Abs,
    Mauricio Cruz (29/03/2012 09:06): Ahm, a Daiane explicou e tal, mas a estrutura da RFC n√£o importa muito para o exemplo. Tanto faz quais s√£o os par√¢metros, o funcionamento do paralelismo, que √© o importante do post, √© o mesmo. Ah, e para quem n√£o sabe: quando falamos ‚ÄúRFC‚Äù, estamos falando de uma fun√ß√£o criada pela SE37/SE80 (e derivados do leite), mas que na primeira aba de caracter√≠sticas deve ter a op√ß√£o ‚Äúm√≥dulo de fun√ß√£o remota‚Äù marcada.
    Mauricio Cruz (29/03/2012 09:06): Ahm, a Daiane explicou e tal, mas a estrutura da RFC n√£o importa muito para o exemplo. Tanto faz quais s√£o os par√¢metros, o funcionamento do paralelismo, que √© o importante do post, √© o mesmo. Ah, e para quem n√£o sabe: quando falamos ‚ÄúRFC‚Äù, estamos falando de uma fun√ß√£o criada pela SE37/SE80 (e derivados do leite), mas que na primeira aba de caracter√≠sticas deve ter a op√ß√£o ‚Äúm√≥dulo de fun√ß√£o remota‚Äù marcada.
Gabriel Tognoli (14/03/2012 14:18): Prezados, Gostei do post e o incr√≠vel √© que estou estudando o uso de RFC para um poss√≠vel desenvolvimento, mas acho que voc√™s n√£o est√£o cumprindo com o prometido! Lembro de um post em que voc√™s comentam que est√£o abolindo o uso de c√≥digos procedurais. Cade o ABAP Objects? cad√™ as classes, os objetos, etc‚Ä¶??
  Daiane Zigiotto (14/03/2012 14:46): Oi Gabriel! Obrigada pelo coment√°rio! A ideia do post era somente mostrar o conceito de RFC Ass√≠ncrona, mas se voc√™ preferir, ao inv√©s de usar CALL FUNCTION‚Ä¶ PERFORMING (subrotina) voc√™ pode usar CALL FUNCTION‚Ä¶ CALLING (m√©todo). Abra√ßos!
    Mauro Laranjeira (15/03/2012 12:19): =O essa eu n√£o s√°bia. Vivendo a aprendendo, rs
    Mauro Laranjeira (15/03/2012 12:19): =O essa eu n√£o s√°bia. Vivendo a aprendendo, rs
  Mauricio Cruz (14/03/2012 14:20): Ol√° Gabriel! Na verdade, quem falou que ia deixar de programar de forma procedural fui eu, nesse post aqui ! A id√©ia do ABAPZombie n√£o √© trocar todas as dicas que damos aqui para OO, cada um dos membros trabalha da maneira que achar melhor. Mas o Mauro e eu estamos preparando algumas coisas divertidas para as pr√≥ximas semanas. Acho que voc√™ vai gostar üòÄ Abra√ßos!
    Rodrigo (27/04/2012 12:06): Aee Mauricio‚Ä¶ vc sabe minha opini√£o! heheh Eu odeio OO mas tudo bem‚Ä¶ n√£o programo mais mesmo!! heheh
    Gabriel Tognoli (14/03/2012 14:59): Maurico/Daiane, Meus amigos, obrigado pelo retorno! Comentei no intuito de desenvolvermos uma comunidade cada vez mais forte, deixando de lado velhos h√°bitos e rotinas, que faz√≠amos e que fazemos at√© hoje. Eu mesmo, sempre que penso em uma solu√ß√£o, me vem na cabe√ßa o maldito procedural. Farei uma compara√ß√£o com o ingl√™s‚Ä¶ Estudar no Brasil ou no exterior talvez n√£o seja t√£o diferente, mas ao estar em outro pa√≠s, nos vemos obrigados a entender e estudar, pq TUDO √© ingl√™s. Tamb√©m estou adotando esta postura, mudar os meus c√≥digos procedurais para OO. Confesso que ainda carrego comigo as velhas manias, acho at√© que vou recorrer a uma lobotomia! rs
    Rodrigo (27/04/2012 12:06): Aee Mauricio‚Ä¶ vc sabe minha opini√£o! heheh Eu odeio OO mas tudo bem‚Ä¶ n√£o programo mais mesmo!! heheh
    Gabriel Tognoli (14/03/2012 14:59): Maurico/Daiane, Meus amigos, obrigado pelo retorno! Comentei no intuito de desenvolvermos uma comunidade cada vez mais forte, deixando de lado velhos h√°bitos e rotinas, que faz√≠amos e que fazemos at√© hoje. Eu mesmo, sempre que penso em uma solu√ß√£o, me vem na cabe√ßa o maldito procedural. Farei uma compara√ß√£o com o ingl√™s‚Ä¶ Estudar no Brasil ou no exterior talvez n√£o seja t√£o diferente, mas ao estar em outro pa√≠s, nos vemos obrigados a entender e estudar, pq TUDO √© ingl√™s. Tamb√©m estou adotando esta postura, mudar os meus c√≥digos procedurais para OO. Confesso que ainda carrego comigo as velhas manias, acho at√© que vou recorrer a uma lobotomia! rs
  Daiane Zigiotto (14/03/2012 14:46): Oi Gabriel! Obrigada pelo coment√°rio! A ideia do post era somente mostrar o conceito de RFC Ass√≠ncrona, mas se voc√™ preferir, ao inv√©s de usar CALL FUNCTION‚Ä¶ PERFORMING (subrotina) voc√™ pode usar CALL FUNCTION‚Ä¶ CALLING (m√©todo). Abra√ßos!
    Mauro Laranjeira (15/03/2012 12:19): =O essa eu n√£o s√°bia. Vivendo a aprendendo, rs
    Mauro Laranjeira (15/03/2012 12:19): =O essa eu n√£o s√°bia. Vivendo a aprendendo, rs
  Mauricio Cruz (14/03/2012 14:20): Ol√° Gabriel! Na verdade, quem falou que ia deixar de programar de forma procedural fui eu, nesse post aqui ! A id√©ia do ABAPZombie n√£o √© trocar todas as dicas que damos aqui para OO, cada um dos membros trabalha da maneira que achar melhor. Mas o Mauro e eu estamos preparando algumas coisas divertidas para as pr√≥ximas semanas. Acho que voc√™ vai gostar üòÄ Abra√ßos!
    Rodrigo (27/04/2012 12:06): Aee Mauricio‚Ä¶ vc sabe minha opini√£o! heheh Eu odeio OO mas tudo bem‚Ä¶ n√£o programo mais mesmo!! heheh
    Gabriel Tognoli (14/03/2012 14:59): Maurico/Daiane, Meus amigos, obrigado pelo retorno! Comentei no intuito de desenvolvermos uma comunidade cada vez mais forte, deixando de lado velhos h√°bitos e rotinas, que faz√≠amos e que fazemos at√© hoje. Eu mesmo, sempre que penso em uma solu√ß√£o, me vem na cabe√ßa o maldito procedural. Farei uma compara√ß√£o com o ingl√™s‚Ä¶ Estudar no Brasil ou no exterior talvez n√£o seja t√£o diferente, mas ao estar em outro pa√≠s, nos vemos obrigados a entender e estudar, pq TUDO √© ingl√™s. Tamb√©m estou adotando esta postura, mudar os meus c√≥digos procedurais para OO. Confesso que ainda carrego comigo as velhas manias, acho at√© que vou recorrer a uma lobotomia! rs
    Rodrigo (27/04/2012 12:06): Aee Mauricio‚Ä¶ vc sabe minha opini√£o! heheh Eu odeio OO mas tudo bem‚Ä¶ n√£o programo mais mesmo!! heheh
    Gabriel Tognoli (14/03/2012 14:59): Maurico/Daiane, Meus amigos, obrigado pelo retorno! Comentei no intuito de desenvolvermos uma comunidade cada vez mais forte, deixando de lado velhos h√°bitos e rotinas, que faz√≠amos e que fazemos at√© hoje. Eu mesmo, sempre que penso em uma solu√ß√£o, me vem na cabe√ßa o maldito procedural. Farei uma compara√ß√£o com o ingl√™s‚Ä¶ Estudar no Brasil ou no exterior talvez n√£o seja t√£o diferente, mas ao estar em outro pa√≠s, nos vemos obrigados a entender e estudar, pq TUDO √© ingl√™s. Tamb√©m estou adotando esta postura, mudar os meus c√≥digos procedurais para OO. Confesso que ainda carrego comigo as velhas manias, acho at√© que vou recorrer a uma lobotomia! rs
Mauro Laranjeira (14/03/2012 09:16): aEEE Dai, Parab√©ns, post Legal Estadual e Bonito (Acho que s√≥ a Dai vai entender) Curti muito, muito mesmo. Abs.
  Daiane Zigiotto (14/03/2012 17:16): Valeu Mauro! üòÄ Para quem quiser entender tamb√©m, assista esse v√≠deo -> http://www.youtube.com/watch?v=lZCRuy7hkpA uhsaushuahsuhauhsua
  Daiane Zigiotto (14/03/2012 17:16): Valeu Mauro! üòÄ Para quem quiser entender tamb√©m, assista esse v√≠deo -> http://www.youtube.com/watch?v=lZCRuy7hkpA uhsaushuahsuhauhsua
Custodio (12/03/2012 19:50): Ou eu estou bebado, ou esta faltando um monte de codigo nesse post, nao?
  Daiane Zigiotto (12/03/2012 22:13): Quando fui passar o c√≥digo-fonte acabou cortando uma parte, mas j√° est√° corrigido!!!
  Miguel (12/03/2012 21:51): Hahaha! Estava me perguntando a mesma coisa! Quando corrigido ser√° um post muito √∫til!
    Daiane Zigiotto (12/03/2012 22:25): J√° corrigi o c√≥digo-fonte, obrigada por avisar!
    Daiane Zigiotto (12/03/2012 22:25): J√° corrigi o c√≥digo-fonte, obrigada por avisar!
  Daiane Zigiotto (12/03/2012 22:13): Quando fui passar o c√≥digo-fonte acabou cortando uma parte, mas j√° est√° corrigido!!!
  Miguel (12/03/2012 21:51): Hahaha! Estava me perguntando a mesma coisa! Quando corrigido ser√° um post muito √∫til!
    Daiane Zigiotto (12/03/2012 22:25): J√° corrigi o c√≥digo-fonte, obrigada por avisar!
    Daiane Zigiotto (12/03/2012 22:25): J√° corrigi o c√≥digo-fonte, obrigada por avisar!