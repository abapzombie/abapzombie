Seguran√ßa ABAP ‚Äì Parte I ‚Äì C√≥digo din√¢mico
Autor: Leo Schmidt
Data: 02/07/2012 14:00

Fala zombizada! Aqui quem fala √© o seu camarada
@ABAPdepressao
, vindo diretamente do mundinho do Twitter onde compartilho das tristezas di√°rias de programar em alem√£o com voc√™s. O Maur√≠cio me convidou pra escrever aqui no ABAP Zombie, e eu tentei escolher um tema bacana pra n√£o estragar logo de cara o blog com o meu humor depressivo (ou deprimente). Ent√£o vou tentar falar de seguran√ßa dentro do ABAP.
‚ÄúMeu nome √© AUTHORITY-CHECK, e o seu SY-SUBRC √© DOZE‚Äù
Seguran√ßa da informa√ß√£o √© um assunto que me interessa bastante. Essa √© uma √°rea cr√≠tica em qualquer sistema, e dentro do SAP n√£o √© diferente. Muitos elementos j√° est√£o ali para garantir a seguran√ßa, como o modelo de autoriza√ß√£o, a criptografia e as pol√≠ticas de senha, o transporte e versionamento de c√≥digo, a separa√ß√£o de sistemas no
landscape
(DEV>QAS>PRD),
Single Sign-On
,
patches
de seguran√ßa, etc. Todas essas coisas, quando bem administradas, tornam o SAP um sistema seguro.
Quando eu comecei a trabalhar com SAP, ainda estagi√°rio de Basis, eu n√£o cheguei a mexer com tudo isso, mas s√≥ com a parte de administra√ß√£o de usu√°rios e perfis. Sempre tinha muito trabalho pra fazer, porque o cliente tinha pol√≠ticas bem definidas para as contas de usu√°rios e segrega√ß√£o de fun√ß√µes. S√≥ que depois que eu passei pra √°rea de ABAP, eu percebi que n√£o havia o mesmo cuidado dentro do c√≥digo. A equipe de Basis era respons√°vel por garantir acesso √†s transa√ß√µes e aos programas desenvolvidos, mas uma vez dentro dos mesmos o m√°ximo que acontecia era um AUTHORITY-CHECK aqui e outro ali.
Isso me espantou de in√≠cio, mas depois eu entendi que o
standard
√© quem implementa a maior parte da seguran√ßa dentro do SAP, atrav√©s dos elementos que eu citei anteriormente. √â claro que isso n√£o tira a responsabilidade do ABAPer de usar AUTHORITY-CHECKs nos lugares necess√°rios, mas acaba tirando um grande peso das costas do desenvolvimento, diferentemente do que acontece em outras linguagens.
Mas quando falamos de
vulnerabilidades
, sim, o ABAP √© parecido com outras linguagens. Fu√ßando na net eu encontrei um
white paper
que fala sobre o tema. √â um estudo de uma empresa de seguran√ßa de
software
alem√£ chamada VirtualForge sobre os riscos do ABAP, mais especificamente sobre comunica√ß√£o com o
kernel
do SAP e
buffer overflows
. S√£o 27 p√°ginas com alguns exemplos, ent√£o √© um documento razoavelmente extenso, por√©m interessante.
Antes de me prolongar sobre o tema, √© importante ressaltar o seguinte:
todas
as vulnerabilidades que est√£o expostas nesse documento podem ser (pra usar o jarg√£o de seguran√ßa :D) mitigadas dentro dos desenvolvimentos atrav√©s de: 1- controle do sistema bem exercido pela equipe de Basis e 2-
peer review
, a famigerada revis√£o por pares.
O documento classifica as vulnerabilidades pelo risco (baixo / m√©dio / alto / muito alto). N√£o vou falar de todas elas agora ‚Äì fica pras pr√≥ximas partes ‚Äì mas vou come√ßar com uma que acho bastante complicada:
c√≥digo din√¢mico
.
Por ‚Äúc√≥digo din√¢mico‚Äù entenda-se c√≥digo que n√£o √© totalmente compilado, porque possui partes vari√°veis que s√≥ s√£o determinadas em tempo de execu√ß√£o. Os casos mais simples de c√≥digo din√¢mico em ABAP s√£o certos comandos que aceitam refer√™ncias como par√¢metros. Vejamos dois exemplos:
1- Usando ASSIGN:
DATA: lv_segredo TYPE string VALUE ‚ÄòSegredo‚Äô,
      lv_aberto¬† TYPE string VALUE ‚ÄòAberto‚Äô.

PARAMETERS p_ref TYPE string DEFAULT ‚Äòlv_aberto‚Äô.

FIELD-SYMBOLS <fs_ref> TYPE ANY.

ASSIGN (p_ref) TO <fs_ref>.
2- Usando OpenSQL:
PARAMETERS p_where TYPE string DEFAULT ‚Äòbname = sy-uname‚Äô.

DELETE FROM usr01 WHERE (p_where).
Ao passar um par√¢metro entre par√™nteses, n√£o √© a vari√°vel declarada diretamente que est√° sendo usada, mas sim o valor dela. Isso pode abrir um precedente para que esses valores sejam alterados em tempo de execu√ß√£o, permitindo assim que o programa leia dados que n√£o deveria (caso do ASSIGN, se mudarmos o valor da P_REF), ou execute comandos usando dados diferentes dos que a l√≥gica da aplica√ß√£o pretendia usar (caso do DELETE, mudando o valor da P_WHERE).
Isso j√° seria dor de cabe√ßa suficiente para um Basis, principalmente quando falamos de intera√ß√£o com o banco de dados. Mas como se n√£o bastasse, existe tamb√©m um comando nem t√£o conhecido que pode gerar c√≥digo
totalmente
din√¢mico: o
GENERATE SUBROUTINE POOL
. Exemplo:
REPORT¬† z_codigo_dinamico.

DATA: t_pool TYPE TABLE OF string,
      v_prog TYPE¬†         string.

APPEND: 'PROGRAM pool.'                          TO t_pool,
        'FORM mensagem.'                         TO t_pool,
        '¬† WRITE / ''C√≥digo din√¢mico chamado''.' TO t_pool,
        'ENDFORM.'¬†                              TO t_pool.

GENERATE SUBROUTINE POOL t_pool NAME v_prog.

WRITE: 'Nome do programa gerado: ', v_prog.

PERFORM ('MENSAGEM') IN PROGRAM (v_prog) IF FOUND.
Exemplo de sa√≠da do programa:
Nome do programa gerado:¬† %_T00E10

C√≥digo din√¢mico chamado
Impressionou? N√£o? Ent√£o vamos analisar duas coisas:
O c√≥digo criado com GENERATE SUBROUTINE POOL √© transformado em
byte code
em tempo de execu√ß√£o,
sem nunca ser gravado no banco de dados
como acontece com um programa comum (feito atrav√©s da SE38, SE24, SE80, etc);
O nome do
subroutine pool
√© gerado dinamicamente e come√ßa com ‚Äú%_‚Äù, portanto
est√° fora dos
namespaces
do cliente
(Z*, Y*, /NAMESPACE_DO_CLIENTE/*). Dessa forma, investigar o funcionamento do c√≥digo din√¢mico atrav√©s de
traces
fica muito mais dif√≠cil.
N√£o precisa juntar nem 2 + 2 pra entender que se a gera√ß√£o de c√≥digo din√¢mico estiver sujeita a
input
externo (seja por tela de sele√ß√£o, leitura de arquivo, interface PI, ABAP Proxy, etc.) o programa pode fazer
qualquer coisa
. Isso √© um risco
MUITO GRANDE
.
Isso tamb√©m √© um risco muito grande, mas esse sai com Colorcote 2000. NOSSA, NOSTALGIA FORTE
Eu sei que podem existir situa√ß√µes muito complexas em que essas t√©cnicas se fazem necess√°rias, mas a moral aqui √© bem evidente:
evite usar c√≥digo din√¢mico
, e se tiver que usar,
policie muito bem as entradas
. Seu amigo (?) Basis agradece quando rolar aquela auditoria.
At√© a pr√≥xima, onde vou tentar falar sobre os
kernel calls
.



Coment√°rios:
roberto florentino (29/08/2013 15:23): Mat√©ria muito interessante, despertou a necessidade de termos alguma pessoa cuidando da quest√£o da qualidade dos desenvolvimentos em abap, com foco na seguran√ßa e performance
Jahniffer Santos (06/06/2013 13:45): kkkk‚Ä¶ (‚Ä¶Isso √© um risco MUITO GRANDE‚Ä¶)‚Ä¶ Muito legal. Tamb√©m gostei muito do artigo. Uma pitadinha de Basis no ABAP para ajudar a seguran√ßa. Viva o compartilhamento do conhecimento!!!
Diego Henrique Gomes (02/07/2012 23:29): kkkkkkkkkkkkkkkkkkkk estou rindo com o Risco Grande at√© agora!!! Muito bom o artigo‚Ä¶ mas a seguran√ßa sempre fica para ‚Äúconfian√ßa‚Äù
Mauricio Cruz (02/07/2012 15:10): S√≥ pra constar, vale a pena ler o White Paper que o mano depressivo citou. Eu j√° trabalhei com uma galera que manjava dessa parte de seguran√ßa em ABAP, e √© bem interessante analisar sua aplica√ß√£o desse outro ponto de vista üôÇ E que venha a parte 2! Abra√ßos!