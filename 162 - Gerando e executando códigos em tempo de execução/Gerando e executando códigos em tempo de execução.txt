Gerando e executando c√≥digos em tempo de execu√ß√£o
Autor: Mauricio Cruz
Data: 28/11/2012 10:32

N√£o se confunda com o t√≠tulo, caro zumbi das neves! √â isso mesmo: a execu√ß√£o do seu programa principal vai gerar e executar um outro c√≥digo. A id√©ia deste post veio de um coment√°rio recente que foi feito num
post antigo aqui
do site. A pergunta do milh√£o √©: o que fazer quando o n√≠vel de dinamicidade est√° alt√≠ssimo e o field-symbol n√£o √© o bastante?
Vegeta, ao avistar os n√≠veis de dinamicidade deste post
Ah, o GENERATE SUBROUTINE POOL. Ainda hoje eu me lembro do dia em que eu vi o tal do ‚Äúprograma completamente din√¢mico‚Äù. Era um report que criava um c√≥digo ABAP de acordo com o que o user escolhia na tela de sele√ß√£o, e executava-o logo em seguida. Note que ele n√£o gerava um programa est√°tico (n√£o existia um ‚Äúnome de programa‚Äù na SE80), ele montava, executava e ‚Äúeliminava‚Äù o c√≥digo dentro da mesma ‚Äújanela de execu√ß√£o‚Äù. O ABAP Noob que existia dentro de mim ficou maravilhado com tal proeza.
Mas da√≠ voc√™ me pergunta ‚Äút√° Mauricio, mas para que diabos serve isso de gerar um programa dentro de um programa‚Äù? Se voc√™ j√° utilizou aquela classe bacanuda para gerar tabelas internas de forma din√¢mica atrav√©s do preenchimento um fieldcat (cl_alv_table_create), saiba que voc√™ j√° utilizou o GENERATE SUBROUTINE POOL por tabela! Lembre-se: n√£o existe m√°gica no mundo da programa√ß√£o.
E ae, vamos aprender a usar esse neg√≥cio?
A id√©ia √© beeem mais simples do que parece. Tudo que voc√™ precisa fazer √© montar o seu FORM dentro de uma tabela interna. Exemplo:
REPORT zombie_dinamicidadeextrema.

DATA: t_code ¬† ¬† ¬† TYPE TABLE OF string,
¬† ¬† ¬† l_line ¬† ¬† ¬† LIKE LINE OF t_code,
¬† ¬† ¬† l_prog_temp ¬†TYPE string.

l_line = 'PROGRAM eusoudinamico.'.
APPEND l_line TO t_code.

l_line = 'FORM escreva_algo.'.
APPEND l_line TO t_code.

l_line = 'WRITE ''algo''.'.
APPEND l_line TO t_code.

l_line = 'ENDFORM.'.
APPEND l_line TO t_code.
Depois, voc√™ deve utilizar o comando GENERATE SUBROUTINE POOL, passando como par√¢metro a tabela que acabou de criar. Esse √© o comando que vai criar o ‚Äúprograma‚Äù em tempo de execu√ß√£o.
GENERATE SUBROUTINE POOL t_code NAME l_prog_temp.
*Voc√™ ainda pode colocar outros par√¢metros batutas nesse comando. F1 nele üôÇ
O par√¢metro L_PROG_TEMP vai retornar o nome do programa tempor√°rio que foi criado. Agora √© s√≥ fazer um PERFORM‚Ä¶ IN PROGRAM para poder chamar o c√≥digo.
PERFORM ('ESCREVA_ALGO') IN PROGRAM (l_prog_temp).
E pronto! Voc√™ vai ver ‚Äúalgo‚Äù escrito na tela.
√â importante dizer que o c√≥digo que voc√™ colocar dentro de T_CODE deve estar sintaticamente correto, caso contr√°rio, a vari√°vel L_PROG_NAME vai ficar vazia, o comando vai retornar um SY-SUBRC diferente de 0 e um DUMP vai ser disparado no PERFORM‚Ä¶IN PROGRAM.
F√°cil, diz a√≠? E as possibilidades s√£o infinitas! Quer um exemplo?
Como eu disse ali em cima, o m√©todo CL_ALV_TABLE_CREATE=>CREATE_DYNAMIC_TABLE √© utilizado para criar tabelas din√¢micas.
Neste post
eu expliquei com exemplos, como fazer uma tabela din√¢mica + select din√¢mico. Pegue o c√≥digo, copie num programa tempor√°rio e comece a depurar. Coloque um break-point no comando GENERATE SUBROUTINE POOL, e veja a
magia-que-n√£o-√©-mais-magia
acontecer:
N√£o √© feiti√ßaria, √© tecnologia! (s√≥ os FORTES ir√£o ver o FORM din√¢mico que declara a tabela sendo executado)
Uma curiosidade sobre essa t√©cnica, √© que existe um limite no n√∫mero de programas que voc√™ pode criar em tempo de execu√ß√£o. Vou explicar como descobri isso com uma breve hist√≥ria:
Certa vez, um amigo meu tinha um programa que precisava fazer selects em mais ou menos 40 tabelas (ou algo assim), que eram mais ou menos parecidas entre si. Pensamos em utilizar a t√©cnica de SELECTs din√¢micos, utilizando tabelas de retorno geradas dinamicamente pelo m√©todo CL_ALV_TABLE_CREATE=>CREATE_DYNAMIC_TABLE. Ele codificou tudo, de um trabalh√£o‚Ä¶ Mas, na hora dos testes, come√ßamos a enfrentar um DUMP ap√≥s cerca de 35 cria√ß√µes de tabelas din√¢micas. Eu ajudei-o a identificar o problema, e debugamos o standard at√© chegar no ponto onde o sistema busca esse valor, atrav√©s de uma Kernel Call. Esse n√∫mero m√°ximo de Subroutine Pools gerados √© fixo, e, at√© onde eu sei pela pesquisa que fiz na √©poca, n√£o d√° para configurar.
A gente acabou pensando em alguma outra solu√ß√£o besta, que eu acho que deu certo. Mas tamb√©m se n√£o deu, aquela era a hora perfeita de eu dizer ‚Äú
se vira colega
‚Äú, j√° que o produto n√£o era da minha responsabilidade üòà . Obviamente eu n√£o fiz isso ( üôÑ ) e demos um jeito.
Espero que tenham se divertido! Abra√ßos e at√© a pr√≥xima!



Coment√°rios:
igor vilela (15/10/2013 12:43): eu passei por esse problema, a solu√ß√£o e vc gerar o c√≥digo do programa e exportar ele pra mem√≥ria, ap√≥s isso vc da um submit  em um outro programa, nesse outro programa vc pega o codigo exportado pra memoria e cria a subrotina. feito isso vc vai ter burlado o limite de criacao de subrotinas. att., igor vilela
Diego (21/07/2013 14:58): Muito bom o post‚Ä¶ mas h√° que se fazer um alerta. Execu√ß√£o din√¢mica de c√≥digo √© muito bom para alguns casos mas muito perigoso tamb√©m. Algu√©m com inten√ß√µes duvidosas pode, com um simples debug, alterar o conte√∫do do c√≥digo din√¢mico e destruir o SAP. Eu mesmo consegui inserir um comando em um form din√¢mico que era capaz de me dar todos os acessos de SAP* sem alterar nenhuma tabela‚Ä¶ tudo em tempo de execu√ß√£o.
Paulo Sales (04/12/2012 16:03): Muito √∫til! Valeu pelo post.
Kaio Almeida (02/12/2012 00:22): Muito bom o post!!