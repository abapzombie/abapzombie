ALVs Standard: Reutilizando o caos alem√£o
Autor: Daiane Medeiros
Data: 19/09/2013 12:00

Queridos zumbis, alguma vez voc√™s j√° passaram pela seguinte situa√ß√£o: o seu programa precisa usar as informa√ß√µes de algum relat√≥rio ALV, por√©m o relat√≥rio n√£o est√° escrito de uma forma que faz com que o c√≥digo fosse facilmente reutiliz√°vel?
Frustrante, n√£o √©?! üôÅ
Bom, dependendo do relat√≥rio, h√° sim uma chance de reutilizar a extra√ß√£o de dados e o c√≥digo de processamento. Por√©m, meu amigo zumbi, infelizmente voc√™ vai descobrir que existem pouqu√≠ssimos relat√≥rios standard que podem ser reutilizados com facilidade, principalmente quando come√ßa os coment√°rios em alem√£o e voc√™ tenta traduzi-los na esperan√ßa de entender alguma coisa (admita, voc√™ j√° fez isso!).
Ent√£o, e agora?
Se voc√™ encontrar um relat√≥rio que tem a l√≥gica que voc√™ precisa, pode ter uma outra maneira de reutiliz√°-lo sem precisar
clonar programas
ou ficar copiando c√≥digo. Voc√™ pode chamar o relat√≥rio dentro do seu programa e trat√°-lo como uma rotina. Essa t√©cnica pode te ajudar a reduzir o esfor√ßo do desenvolvimento e reutilizar objetos que j√° existem.
Mas como isso funciona?
Depois da extra√ß√£o e processamento, os relat√≥rios ALV exportam os dados para uma √°rea de mem√≥ria global e isso permite que o seu programa possa import√°-los depois.
Quando um relat√≥rio ALV √© executado, as informa√ß√µes em tempo de execu√ß√£o (layout, fieldcat, tabelas e etc.) s√£o armazenadas pelos m√©todos da classe CL_SALV_BS_RUNTIME_INFO. Ali√°s, essa classe usa o EXPORT TO MEMORY para armazenar as informa√ß√µes. A classe lida com tudo isso internamente e fornece m√©todos para acessar essas informa√ß√µes, ou seja, n√£o precisamos nos preocupar como elas s√£o armazenadas.
Exemplo:
Vou usar como exemplo o relat√≥rio IE05, informando o n√∫mero do invent√°rio e centro na tela de sele√ß√£o. Essa √© a sa√≠da do relat√≥rio:
Agora vou chamar o relat√≥rio dentro do meu programa, passando os mesmos valores para os par√¢metros de sele√ß√£o e importar os dados para uma tabela interna:
DATA: lt_selscreen TYPE TABLE OF rsparams,
      wa_selscreen TYPE rsparams.

FIELD-SYMBOLS <lt_data>   TYPE ANY TABLE.
DATA lr_data              TYPE REF TO data.

* Monta a tabela com os dados do par√¢metro de sele√ß√£o
wa_selscreen-selname = 'INVNR'.   "Nome do campo
wa_selscreen-kind    = 'S'.       "Tipo (P - parameter /S - select-options)
wa_selscreen-sign    = 'I'.
wa_selscreen-option  = 'BT'.
wa_selscreen-low     = '120000'.
wa_selscreen-high    = '161000'.
APPEND wa_selscreen TO lt_selscreen.
CLEAR wa_selscreen.

wa_selscreen-selname = 'SWERK'. "Nome do campo
wa_selscreen-kind    = 'S'.     "Tipo (P - parameter /S - select-options)
wa_selscreen-sign    = 'I'.
wa_selscreen-option  = 'EQ'.
wa_selscreen-low     = '331'.
APPEND wa_selscreen TO lt_selscreen.
CLEAR wa_selscreen.

cl_salv_bs_runtime_info=>set(
  EXPORTING display  = abap_false
            metadata = abap_false
            data     = abap_true ).

* Executa o relat√≥rio e importa a tabela de saida
SUBMIT riequi20
  WITH SELECTION-TABLE lt_selscreen
  AND RETURN.
TRY.
    cl_salv_bs_runtime_info=>get_data_ref(
      IMPORTING r_data = lr_data ).
    ASSIGN lr_data->* TO <lt_data>.
  CATCH cx_salv_bs_sc_runtime_info.
    MESSAGE 'N√£o √© poss√≠vel recuperar os dados ALV' TYPE 'E'.

ENDTRY.

cl_salv_bs_runtime_info=>clear_all( ).
Resultado da tabela preenchida:
Simples, n√£o √©? Vou explicar os m√©todos e os par√¢metros utilizados pela classe CL_SALV_BS_RUNTIME_INFO:
SET () ‚Äì m√©todo que inicializa a classe.
‚Ä¢ DISPLAY ‚Äì Defina como ‚Äúabap_false‚Äù para for√ßar o relat√≥rio ALV ser executado em ‚Äúbackground‚Äù, ou seja, o ALV n√£o ser√° exibido.
‚Ä¢ METADATA ‚Äì Defina como ‚Äúabap_false‚Äù para evitar que o layout, fieldcat, etc, sejam exportados para a mem√≥ria‚Ä¶ a gente n√£o precisa deles neste cen√°rio.
‚Ä¢ DATA ‚Äì Defina como ‚Äúabap_true‚Äù para for√ßar a exporta√ß√£o da tabela de dados para a mem√≥ria.
GET_DATA_REF () ‚Äì Se voc√™ n√£o conhece qual √© a estrutura da tabela, ou prefere usar uma tabela din√¢mica, este m√©todo pode ser usado para acessar a refer√™ncia da tabela.
‚Ä¢ R_DATA ‚Äì par√¢metro de exporta√ß√£o da tabela.
CLEAR_ALL () ‚Äì este m√©todo limpa todas as √°reas de mem√≥ria, redefinindo os flags que foram definidos no m√©todo SET ().
Essa t√©cnica pode ser utilizada para acessar os dados dos relat√≥rios que usam qualquer tipo de ALV (ALV Grid, ALV List, ALV Tree), mas, obviamente, n√£o vai funcionar para relat√≥rios WRITE ou qualquer coisa que n√£o seja SAPGUI ALV.
√â isso a√≠, espero que isso possa ajud√°-los algum dia! At√© mais e que a for√ßa anti-zumbi esteja com voc√™s!!



Coment√°rios:
Felipe (20/04/2020 10:39): Me ajudou muito üôÇ
marcos (27/11/2019 18:59): Boa Noite, muito boa dica, eu j√° utilizo esta forma de obter dados de alv por√©m estou com uma dificuldade. Quando o relat√≥rio que utilizo este m√©todo j√° faz uso dele para outro alv o resultado passa a ser exibido em tela. J√° passou por isso ?
Reginaldo Russo (08/10/2015 17:09): Pessoal, tamb√©m √© poss√≠vel utilizar o CALL TRANSACTION no lugar do SUBMIT.
Alex (19/12/2014 10:18): Como fa√ßo para os dados que est√£o armazenados lr_data tipo atribuir um campo a uma variavel local.EX: matnr = -MATNR
  Ruan Carvalhaes (22/07/2015 08:18): Basta rebobinar o disquete do programa principal e processar a rebimboca da parafuseta.
  Ruan Carvalhaes (22/07/2015 08:18): Basta rebobinar o disquete do programa principal e processar a rebimboca da parafuseta.
Sandra (07/07/2014 17:12): Muito legal a dica . Me ajudou muito.
Jorge Bastos (12/02/2014 07:03): √ìtima dica Lady Dai! Parab√©ns!!!
Daniel jesus (09/01/2014 08:29): Sensacional! Parab√©ns Daiane!
Mauro Laranjeira (25/09/2013 11:27): Show de Bola Dai‚Ä¶ Parab√©ns =D
Kazu (23/09/2013 09:30): Muito bom Daiane! valew pela informa√ß√£o !
Vinicius Ostan (20/09/2013 13:48): Amazing!!! Muito bom.. Acabei de passar por tal situa√ß√£o, pena n√£o ter lido este t√≥pico antes‚Ä¶ üôÅ Na pr√≥xima vou lembrar do zombie. Obrigado
Renan A. Ferreira (19/09/2013 13:50): P√£tz, √≥tima dica Daiane! Valeu!