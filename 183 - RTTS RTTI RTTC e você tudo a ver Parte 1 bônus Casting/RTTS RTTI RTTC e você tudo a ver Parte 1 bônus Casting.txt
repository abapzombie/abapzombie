RTTS, RTTI, RTTC e voc√™: tudo a ver ‚Äì Parte 1 (b√¥nus: Casting)
Autor: Mauricio Cruz
Data: 25/04/2014 08:30

Todo mundo adora fazer coisas ‚Äúdin√¢micas‚Äù em seus programas, certo? Para essa finalidade, a hierarquia de classes conhecida como RTTS tem muitas ferramentas que podem ajud√°-lo a resolver problemas malucos onde voc√™ precisa criar/identificar vari√°veis din√¢micamente no seu programa (seja l√° qual for o seu motivo).
Nesta s√©rie de¬†posts vou explicar um pouco sobre como (mais) esse monte de siglas pode tornar-se uma arma valiosa para matar aquela EF zumbi que te persegue de noite, no banho, no carro e em todos os seus pensamentos.
Na
Parte 1
n√≥s vamos tentar decifrar essa sopa de letrinhas, entender o que √© down-cast e ver um¬†exemplo simples(s√≥ para voc√™ n√£o me xingar e dizer que o post √© pura¬†teoria).
Na
Parte 2
vamos explorar algumas fun√ß√µes para analisar vari√°veis em tempo de execu√ß√£o.
Na
Parte 3
, vamos descobrir como utilizar as ferramentas do RTTS para criar outras vari√°veis.
Prepare¬†a sua pipoca sabor¬†c√©rebros e vamos l√°!
V√©io, RTTOQUE?
N√£o adianta reclamar de siglas amigo cambaleante, voc√™ escolheu ser programador. Voc√™ poderia ter jogado futebol, basquete, vol√™i, queimada, peteca‚Ä¶ mas¬†j√° que escolheu ficar a√≠ sentando aguentando usu√°rios chatos, vamos entender o que quer dizer cada uma dessas siglas:
RTTS ‚Äì Runtime Type Services,
ou ‚ÄúParadas Legais para usar em Tempo de Execu√ß√£o‚Äù. Consiste de 2 componentes:
RTTC: Runtime Type Creation:
Cria√ß√£o din√¢mica em tempo de execu√ß√£o. Ex.: Criar uma nova vari√°vel do tipo CHAR 30.
RTTI: Runtime Type Identification:
Identifica√ß√£o de tipos em tempo de execu√ß√£o. Ex.: Descobrir que o campo ABC da estrutura WA_XYZ √© um CHAR de 20 posi√ß√µes.
Nas minhas pesquisas descobri que, antigamente, s√≥ existiam ferramentas para identifica√ß√£o de tipos, que eram chamadas de RTTI. Com o tempo, a SAP implementou ferramentas para cria√ß√£o de vari√°veis em tempo de execu√ß√£o, e deu o nome de RTTC a elas. Foi ent√£o que surgiu a sigla ‚ÄúRTTS‚Äù, que serve como identificador para essas ferramentas.
Muita gente fica assustada com RTTS pelo mesmo motivo de sempre: voc√™ acessa as ferramentas a partir de uma
hierarquia de classes.
Falou de SE24 os ABAPossauros tremem, eu sei. Mas vem comigo que a coisa √© mais f√°cil do que parece.
Toma a√≠ um exemplo simples para voc√™ ficar com vontade de aprender:
REPORT rtts_rtti_rttc_p_vc.

TYPES: tipo TYPE i.

DATA: variavel TYPE tipo,
      nome     TYPE string.

DATA: typedescr TYPE REF TO cl_abap_typedescr.

* Notem que estamos utilizando a vari√°vel para descrever o seu tipo (TYPE)
typedescr = cl_abap_typedescr=>describe_by_data( variavel ).

WRITE: / typedescr->type_kind. " Output: I (de Inteiro)

* Nome do tipo referenciado pela vari√°vel
nome = typedescr->get_relative_name( ).

WRITE: / nome. "Output: (nome do tipo da variavel).

* Experimente trocar o TYPE de integer para alguma outra coisa! (ex. String)
Classes do RTTS
Para acessar qualquer fun√ß√£o do RTTS, voc√™ precisa utilizar a classe correspondente. O RTTS possui uma hierarquia de classes bem definida, que refletem os tipos e vari√°veis existentes dentro do SAP (types, estruturas, tabelas internas, objetos, etc). D√™ uma olhada
neste link
, tem um mapa bem legal dos tipos existentes no ABAP.
Voc√™ n√£o precisa decorar todas agora, mas √© importante saber que essa hierarquia existe na SE24 mais pr√≥xima de voc√™:
CL_ABAP_TYPEDESCR
|
|‚Äì
CL_ABAP_DATADESCR
|¬†¬† |
|¬†¬† |‚Äì
CL_ABAP_ELEMDESCR
|¬†¬† |‚Äì
CL_ABAP_REFDESCR
|¬†¬† |‚Äì
CL_ABAP_COMPLEXDESCR
|¬†¬†¬†¬†¬†¬† |
|¬†¬†¬†¬†¬†¬† |‚Äì
CL_ABAP_STRUCTDESCR
|¬†¬†¬†¬†¬†¬† |‚Äì
CL_ABAP_TABLEDESCR
|
|‚Äì
CL_ABAP_OBJECTDESCR
|
|‚Äì
CL_ABAP_CLASSDESCR
|‚Äì
CL_ABAP_INTFDESCR
(retirado do
help
)
Para descomplicar um pouco essas siglas de RTTI e RTTC, uma mesma classe possui tanto as fun√ß√µes de descri√ß√£o quando de cria√ß√£o. Ou seja, se eu quiser fazer alguma coisa (criar/descrever) relacionada a tabelas internas, vou utilizar a classe CL_ABAP_TABLEDESCR.
Sim, este √© aquele momento em que voc√™
esquece o que RTTI e RTTC
querem dizer, e
fica s√≥ com o RTTS
na cabe√ßa. A√≠, falei que era f√°cil üòÄ .
Aqui
voc√™ encontra uma descri√ß√£o bem detalhada da hierarquia, com seus respectivos m√©todos RTTIs e RTTCs, al√©m dos atributos de cada classe.
Importante notar que n√£o existe uma classe RTTS espec√≠fica para cada tipo de vari√°vel. Ex.: Todos os tipos de tabelas internas (STANDARD, SORTED, HASHED) podem ser tratados no RTTS pela classe de tabelas CL_ABAP_TABLEDESCR. O resto das classes RTTS tamb√©m funcionam de forma semelhante.
Casting e o o fantasma do operador ?=
Em muitos exemplos da internet relacionados a RTTS voc√™ vai encontrar o operador ?= , e para n√£o fazer as coisas por osmose, vamos tentar entender um pouco do que essa interroga√ß√£o se trata.
Antes de mais nada, d√™ uma lida no post do Mauro
falando sobre heran√ßa
. O conceito de casting est√° diretamente relacionado aos conceitos de heran√ßa.
Este operador serve para que voc√™ consiga fazer um down cast, ou seja, para que voc√™ consiga mover um
objeto¬†de uma classe pai
e passar para um outro objeto que faz refer√™ncia a
uma¬†classe filha
.
Vamos imaginar a seguinte hierarquia de classes:
‚Äî
CL_CELULAR
|
|‚Äì
CL_IPHONE
|‚Äì
CL_GALAXY
|‚Äì
CL_LUMIA
Se eu tiver um objeto do tipo CL_IPHONE, eu irei conseguir envi√°-lo a outra vari√°vel que fa√ßa refer√™ncia a classe CL_CELULAR. O relacionamento ‚ÄúIphone √© um Celular‚Äù √© v√°lido (e facilmente compreendido). Como a classe CL_IPHONE √© filha de CL_CELULAR, a associa√ß√£o √© feita sem problemas, pelo operador ‚Äú=‚Äù. Veja s√≥:
CLASS cl_celular DEFINITION.
ENDCLASS.

CLASS cl_iphone DEFINITION INHERITING FROM cl_celular.
ENDCLASS.

CLASS cl_galaxy DEFINITION INHERITING FROM cl_celular.
ENDCLASS.

CLASS cl_lumia DEFINITION INHERITING FROM cl_celular.
ENDCLASS.

DATA: o_celular TYPE REF TO cl_celular, "Classe Pai de Todas as outras
      o_iphone  TYPE REF TO cl_iphone,
      o_galaxy  TYPE REF TO cl_galaxy,
      o_lumia   TYPE REF TO cl_lumia.

CREATE OBJECT o_iphone.

* Pai = Filho
o_celular = o_iphone.
Esse √© o chamado up-casting, ou seja: voc√™ est√° enviando um
objeto do tipo ‚Äúfilho‚Äù para uma vari√°vel do tipo ‚Äúpai‚Äù
.
Mas e o contr√°rio? E se eu quiser pegar a referencia de CL_IPHONE que est√° na vari√°vel O_CELULAR, e quiser enviar
de volta
a uma vari√°vel do tipo CL_IPHONE?
CLASS cl_celular DEFINITION.
ENDCLASS.

CLASS cl_iphone DEFINITION INHERITING FROM cl_celular.
ENDCLASS.

CLASS cl_galaxy DEFINITION INHERITING FROM cl_celular.
ENDCLASS.

CLASS cl_lumia DEFINITION INHERITING FROM cl_celular.
ENDCLASS.

DATA: o_celular TYPE REF TO cl_celular, "Classe Pai de Todas as outras
      o_iphone  TYPE REF TO cl_iphone,
      o_galaxy  TYPE REF TO cl_galaxy,
      o_lumia   TYPE REF TO cl_lumia.

CREATE OBJECT o_iphone.

* Pai = Filho
o_celular = o_iphone.

* Filho = Pai .... funciona?
o_iphone = o_celular.
A√≠ voc√™ fala ‚Äúok Mauricio, √© bem √≥bvio que isso funcionaria, certo?
Errado
! O verificador de sintaxe ir√° dizer que essa opera√ß√£o n√£o √© poss√≠vel, com uma mensagem que pode parecer absurda: ‚Äú
O_CELULAR n√£o pode ser convertido para o tipo de O_IPHONE
‚Äú.
MAS COMO N√ÉO MEUUUU??? EU ACABEI DE PASSAR ALI EM CIMA!!!!!11!!!!!!!1!1!!ONZE
Acalme-se jovem zumbiwan. Quem garante que o que est√° em O_CELULAR √© mesmo um O_IPHONE? E se fosse um O_GALAXY? E se fosse um O_LUMIA? E se fosse um O_QUALQUERCELULARDAFACEDATERRA?
CLASS cl_celular DEFINITION.
ENDCLASS.

CLASS cl_iphone DEFINITION INHERITING FROM cl_celular.
ENDCLASS.

CLASS cl_galaxy DEFINITION INHERITING FROM cl_celular.
ENDCLASS.

CLASS cl_lumia DEFINITION INHERITING FROM cl_celular.
ENDCLASS.

DATA: o_celular TYPE REF TO cl_celular, "Classe Pai de Todas as outras
      o_iphone  TYPE REF TO cl_iphone,
      o_galaxy  TYPE REF TO cl_galaxy,
      o_lumia   TYPE REF TO cl_lumia.

CREATE OBJECT o_iphone.
CREATE OBJECT o_galaxy.
CREATE OBjeCT o_lumia.

* Pai = Filho
o_celular = o_galaxy.
o_celular = o_iphone.
o_celular = o_lumia.

" o_celular pode fazer refer√™ncia a qualquer um dos filhos!
" e agoooraaaa???
√â nesse momento que voc√™ precisa utilizar o operador ?=. √â como se o verificador de sintaxe falasse para voc√™: ‚Äúeu sei l√° o que tem dentro de O_CELULAR, mas j√° que voc√™ t√° falando que √© um O_IPHONE, eu acredito!‚Äù:
CLASS cl_celular DEFINITION.
ENDCLASS.

CLASS cl_iphone DEFINITION INHERITING FROM cl_celular.
ENDCLASS.

CLASS cl_galaxy DEFINITION INHERITING FROM cl_celular.
ENDCLASS.

CLASS cl_lumia DEFINITION INHERITING FROM cl_celular.
ENDCLASS.

DATA: o_celular TYPE REF TO cl_celular, "Classe Pai de Todas as outras
      o_iphone  TYPE REF TO cl_iphone,
      o_galaxy  TYPE REF TO cl_galaxy,
      o_lumia   TYPE REF TO cl_lumia.

CREATE OBJECT o_iphone.

* Pai = Filho
o_celular = o_iphone.

* Filho = Pai.
o_iphone ?= o_celular.

* Com o ?=, o verificador permite que voc√™ fa√ßa a opera√ß√£o
* por sua conta e risco. Se estiver errado, vai dar DUMP
* e ele vai rir da sua cara.
Eu achei bem bizarro esse neg√≥cio quando estava aprendendo, mas se voc√™ se imaginar no lugar do verificador de sintaxe, faz bastante sentido aquela interroga√ß√£o ali. Serve at√© como um warning, como se o verificador estivesse dizendo: ‚Äúeu entendi o que voc√™ quer fazer maaaaaas‚Ä¶ n√£o tenho como ter certeza se isso vai dar certo.‚Äù.
Finalizando
Hoje voc√™ descobriu que RTTS existe, que serve para fazer maluquices em tempo de execu√ß√£o, e que o operador ‚Äú?=‚Äù serve para fazer down-casting. Nos vemos nos pr√≥ximos posts, onde vamos analisar alguns exemplos de aplica√ß√£o. A regra da d√∫vida continua valendo, ou seja, teve d√∫vida
voc√™ que se vire
poste nos coment√°rios.
Espero que tenham gostado. Abra√ßos a todos que j√° jogaram a culpa no programador (√© com voc√™ que estou falando, verificador de sintaxe! üëø ).



Coment√°rios:
Robson (11/12/2014 12:00): Fala Maur√≠cio, blz? Na verdade meu coment√°rio foi em cima dos ‚Äúcastings‚Äù, esqueci mencionar‚Ä¶ rs O que pra mim n√£o ficou claro √© em que situa√ß√£o surge a necessidade de utilizar. Acredito que com um exemplo real fique mais claro. Abra√ßo!
Robson (10/12/2014 14:00): Voc√™ mostrou ‚Äúcomo‚Äù fazer, mas para mim n√£o ficou claro ‚Äúporque‚Äù ou ‚Äúquando‚Äù fazer. Talvez utilizando um exemplo real ficasse mais claro. Se ficar complicado responder aqui (ou complementar o post), fica a sugest√£o da cria√ß√£o de um novo. Valeu!
  Mauricio Cruz (11/12/2014 09:31): Eae Robson! Concordo que na parte 1 me perdi um pouco na hora de explicar a motiva√ß√£o por tr√°s do aprendizado do RTTS. Eu me empolguei tanto explicando que falhei ao mostrar exemplos claros‚Ä¶ As partes 2 e 3 cont√©m exemplos mais palp√°veis do que √© poss√≠vel fazer com o RTTS. Se mesmo assim ficar com d√∫vidas, comente l√° nos posts beleza? Valeu o coment√°rio, vou levar em considera√ß√£o para explica√ß√µes futuras. Abra√ßos!
  Mauricio Cruz (11/12/2014 09:31): Eae Robson! Concordo que na parte 1 me perdi um pouco na hora de explicar a motiva√ß√£o por tr√°s do aprendizado do RTTS. Eu me empolguei tanto explicando que falhei ao mostrar exemplos claros‚Ä¶ As partes 2 e 3 cont√©m exemplos mais palp√°veis do que √© poss√≠vel fazer com o RTTS. Se mesmo assim ficar com d√∫vidas, comente l√° nos posts beleza? Valeu o coment√°rio, vou levar em considera√ß√£o para explica√ß√µes futuras. Abra√ßos!
Custodio (30/04/2014 22:05): Que bom ver post novo por aqui! Muito bom o assunto, o conteudo e o otimo comentario do Fabio. Bjundas
  Mauricio Cruz (01/05/2014 09:50): Valeu mano da Austr√°lia. Abs!
  Mauricio Cruz (01/05/2014 09:50): Valeu mano da Austr√°lia. Abs!
F√°bio Pagoti (29/04/2014 17:23): O Zumbie saiu da terra novamente! Fico feliz por isso. Falando um pouco mais do operador ?= (ou ?MOVE) note que incluir o ? simplesmente diz ao interpretador que a tentativa de atribui√ß√£o deve ser realizada e que o c√≥digo √© valido. Contudo, a valor das refer√™ncia pode significar uma incompatibilidade de tipos (quando voc√™ tenta jogar um Galaxy em um IPhone por exemplo). Nestes casos apesar do seu c√≥digo ativar ele d√° um dump que pode ser tratado usando a cl√°usula catch em CX_SY_MOVE_CAST_ERROR. Lembrando que o conceito de casting tamb√©m √© v√°lido para interfaces e pode ser tratado da mesma forma.
  Mauricio Cruz (01/05/2014 09:50): √â meu, estamos acordando! üôÇ Valeu por complementar o post F√°bio, abra√ßos!
  Mauricio Cruz (01/05/2014 09:50): √â meu, estamos acordando! üôÇ Valeu por complementar o post F√°bio, abra√ßos!
Mateus Oliveira (29/04/2014 13:15): Parab√©ns Maur√≠cio. Al√©m do conte√∫do muito bem explicado os coment√°rios foram hil√°rios.
  Mauricio Cruz (29/04/2014 13:18): Valeus Mateus, fico feliz que tenha gostado! Abra√ßos!
  Mauricio Cruz (29/04/2014 13:18): Valeus Mateus, fico feliz que tenha gostado! Abra√ßos!
Henrique Dias (28/04/2014 14:43): √ìtimo post, s√≥ faltou a tradu√ß√£o do RTTC e RTTI.
  Mauricio Cruz (29/04/2014 07:02): Mano Henrique, eu j√° falei pra voc√™ parar de acessar o site b√™bado. A explica√ß√£o das siglas est√° logo no come√ßo do post! haha Abs!
    Henrique Dias (29/04/2014 13:19): Faltou a tradu√ß√£o na manolagem igual ao RTTS: RTTS ‚Äì Runtime Type Services,  ou ‚ÄúParadas Legais para usar em Tempo de Execu√ß√£o‚Äù. RTTC: Runtime Type Creation:  Cria√ß√£o din√¢mica em tempo de execu√ß√£o. RTTI: Runtime Type Identification: Identifica√ß√£o de tipos em tempo de execu√ß√£o.
      Mauricio Cruz (29/04/2014 13:20): Ah manjei, foi mal! √â que acabou a inspira√ß√£o na hora üôÅ
      Mauricio Cruz (29/04/2014 13:20): Ah manjei, foi mal! √â que acabou a inspira√ß√£o na hora üôÅ
    Henrique Dias (29/04/2014 13:19): Faltou a tradu√ß√£o na manolagem igual ao RTTS: RTTS ‚Äì Runtime Type Services,  ou ‚ÄúParadas Legais para usar em Tempo de Execu√ß√£o‚Äù. RTTC: Runtime Type Creation:  Cria√ß√£o din√¢mica em tempo de execu√ß√£o. RTTI: Runtime Type Identification: Identifica√ß√£o de tipos em tempo de execu√ß√£o.
      Mauricio Cruz (29/04/2014 13:20): Ah manjei, foi mal! √â que acabou a inspira√ß√£o na hora üôÅ
      Mauricio Cruz (29/04/2014 13:20): Ah manjei, foi mal! √â que acabou a inspira√ß√£o na hora üôÅ
  Mauricio Cruz (29/04/2014 07:02): Mano Henrique, eu j√° falei pra voc√™ parar de acessar o site b√™bado. A explica√ß√£o das siglas est√° logo no come√ßo do post! haha Abs!
    Henrique Dias (29/04/2014 13:19): Faltou a tradu√ß√£o na manolagem igual ao RTTS: RTTS ‚Äì Runtime Type Services,  ou ‚ÄúParadas Legais para usar em Tempo de Execu√ß√£o‚Äù. RTTC: Runtime Type Creation:  Cria√ß√£o din√¢mica em tempo de execu√ß√£o. RTTI: Runtime Type Identification: Identifica√ß√£o de tipos em tempo de execu√ß√£o.
      Mauricio Cruz (29/04/2014 13:20): Ah manjei, foi mal! √â que acabou a inspira√ß√£o na hora üôÅ
      Mauricio Cruz (29/04/2014 13:20): Ah manjei, foi mal! √â que acabou a inspira√ß√£o na hora üôÅ
    Henrique Dias (29/04/2014 13:19): Faltou a tradu√ß√£o na manolagem igual ao RTTS: RTTS ‚Äì Runtime Type Services,  ou ‚ÄúParadas Legais para usar em Tempo de Execu√ß√£o‚Äù. RTTC: Runtime Type Creation:  Cria√ß√£o din√¢mica em tempo de execu√ß√£o. RTTI: Runtime Type Identification: Identifica√ß√£o de tipos em tempo de execu√ß√£o.
      Mauricio Cruz (29/04/2014 13:20): Ah manjei, foi mal! √â que acabou a inspira√ß√£o na hora üôÅ
      Mauricio Cruz (29/04/2014 13:20): Ah manjei, foi mal! √â que acabou a inspira√ß√£o na hora üôÅ