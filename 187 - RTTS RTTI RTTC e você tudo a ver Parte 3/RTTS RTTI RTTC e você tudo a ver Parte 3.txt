RTTS, RTTI, RTTC e voc√™: tudo a ver ‚Äì Parte 3
Autor: Mauricio Cruz
Data: 07/05/2014 09:30

Este √© o post que vai agregar valor no seu camarote: voc√™ aprender√° como criar
‚Äúqualquer parada
‚Äù em tempo de execu√ß√£o com o RTTS. Come√ßamos fazendo cria√ß√µes simples, evoluimos para estruturas e terminamos com a cria√ß√£o de tabelas internas.
Para quem chegou de paraquedas na sequ√™ncia de posts: na
Parte 1
voc√™ aprende¬†o que esse monte de sigla quer dizer e na
Parte 2
aprende¬†a identificar os tipos das vari√°veis em tempo de execu√ß√£o. ¬†Recomendo a leitura desses dois posts antes de fu√ßar na cria√ß√£o, pois desta vez n√£o vou entrar em detalhes b√°sicos.
Pronto para virar um mestre do RTTS?
Cria√ß√£o de vari√°veis simples
Para inspecionar uma vari√°vel, buscamos a refer√™ncia no m√©todo est√°tico das classes do RTTS utilizando os m√©todos que come√ßam com ‚Äúdescribe_*‚Äù. ¬†Para criar uma vari√°vel pelo RTTS, podemos utilizar os
m√©todos ‚Äúgetters‚Äù.
Criamos uma vari√°vel referenciando o objeto que recebemos do¬†m√©todo
‚Äúgetter‚Äù
, e utilizamos field-symbols para acessar seu conte√∫do.
Imagine que queremos criar uma vari√°vel CHAR de exatamente 18 posi√ß√µes, nem mais, nem menos (nem STRING, para dar ‚Äúaquele‚Äù gato e n√£o se preocupar com tamanho). Utilizando a classe CL_ABAP_ELEMDESCR, conseguimos criar qualquer vari√°vel com tipo elementar ( integer, string, char, numchar, etc..), do tamanho que quisermos.
N√£o se assuste com esse papo t√©cnico: analise e entenda o exemplo abaixo. Preste bastante aten√ß√£o no comando
CREATE DATA
, pois ele tem uma extens√£o nova espec√≠fica do RTTS:
DATA: elemdescr TYPE REF TO cl_abap_elemdescr.

DATA: variavel  TYPE REF TO data.

FIELD-SYMBOLS <char> TYPE any.

* Criando uma vari√°vel CHAR de 18 posi√ß√µes.
elemdescr = cl_abap_elemdescr=>get_c( 18 ).

* Aqui a magia do TYPE HANDLE entra em a√ß√£o. Ele foi
* feito especialmente para funcionar com as classes do RTTS
* O comando abaixo quer dizer:
* CRIE uma variavel DO TIPO dessa classe rtts.
CREATE DATA variavel TYPE HANDLE elemdescr.

* Voc√™ n√£o vai conseguir fazer mta coisa com a vari√°vel type ref to data.
* Precisamos utilizar um fieldsymbol para manipular o valor.
ASSIGN variavel->* TO <char>.

* Sao 18 posicoes, ent√£o o 9 teria que ser cortado.
* Teste e veja se o output est√° correto!
<char> = '1234567890123456789'.
WRITE <char>.
‚û°
Conceito importante:
somente instanciar a classe RTTS n√£o cria, de fato, a vari√°vel. Quem aloca a mem√≥ria e cria vari√°vel √© o comando
CREATE DATA‚Ä¶ TYPE HANDLE .
O escopo da vari√°vel (global/local) segue a declara√ß√£o do ‚Äú<nome> TYPE REF TO data‚Äù. Se voc√™ declarar isso como global, a vari√°vel ser√° global, se declarar como local, ela ser√° local.¬†Entenda isto e evite confus√µes!
Mas e a√≠, o c√≥digo acima pareceu muito trabalhoso?
Para o exemplo de uma s√≥ vari√°vel, fazer todo esse rol√™ maluco para criar um CHAR de 18 parece insano. Mas n√£o subestime a flexibilidade do RTTS! Modificando um pouco o exemplo acima,
podemos criar uma m√°quina de gerar vari√°veis
. Veja s√≥:
DATA: elemdescr TYPE REF TO cl_abap_elemdescr.

* Char
elemdescr = cl_abap_elemdescr=>get_c( 10 ).
PERFORM escreva_sei_la_o_que USING elemdescr '1234567890A'.

* Inteiro
elemdescr = cl_abap_elemdescr=>get_i( ).
PERFORM escreva_sei_la_o_que USING elemdescr 123.

* NumChar
elemdescr = cl_abap_elemdescr=>get_n( 5 ).
PERFORM escreva_sei_la_o_que USING elemdescr 987654.

* String
elemdescr = cl_abap_elemdescr=>get_string( ).
PERFORM escreva_sei_la_o_que USING elemdescr 'Prevenindo Consultores e Virarem Zumbis'.

* Packed com Decimais
elemdescr = cl_abap_elemdescr=>get_p( p_length = 10 p_decimals = 5 ).
PERFORM escreva_sei_la_o_que USING elemdescr '1234567890.12345' .

*&---------------------------------------------------------------------*
*&      Form  ESCREVA_SEI_LA_O_QUE
*&---------------------------------------------------------------------*
FORM escreva_sei_la_o_que  USING p_elemdescr TYPE REF TO cl_abap_elemdescr
                                 p_seila.

  DATA: variavel TYPE REF TO data.

  FIELD-SYMBOLS <variavel> TYPE any.

  CREATE DATA variavel TYPE HANDLE p_elemdescr.

  ASSIGN variavel->* TO <variavel>.

  <variavel> = p_seila.
  WRITE: /01 'Tipo:',
          7   p_elemdescr->type_kind,
          20 'Tamanho:',
          35  p_elemdescr->length,
          50 'Valor:',
          60 <variavel>.

ENDFORM.                    " ESCREVA_SEI_LA_O_QUE
Viu s√≥? Eu fiz um mini-form para reutilizar o c√≥digo com o CREATE DATA, ASSIGN e o WRITE. Isso
aumentou a flexibilidade
do meu c√≥digo, pois o meu form n√£o faz a menor id√©ia de que tipo de vari√°vel ele vai escrever. Mas isso n√£o importa, afinal, qualquer vari√°vel criada pela classe CL_ABAP_ELEMDESR pode ser escrita na tela por ele.
Notem que no exemplo eu
n√£o estou guardando as vari√°veis criadas
em lugar nenhum, s√≥ estou gerando uma vari√°vel, escrevendo o seu valor e esquecendo que ela existe.¬†¬†Na sua implementa√ß√£o voc√™ pode guardar os valores declarando vari√°veis ‚ÄúTYPE REF TO data‚Äù
diferentes
para cada uma das vari√°veis que voc√™ quiser guardar, com o escopo que preferir (global/local).
Outro ponto importante, √© notar que a classe CL_ABAP_ELEMDESCR possui um m√©todo ‚Äú
getter
‚Äù espec√≠fico para cada tipo elementar. Se eu quero um integer, utilizo o
GET_I,
se quero uma string, o
GET_STRING
, e
assim por diante
. Mas como fica quando eu quiser criar algo com base no DDIC, onde uma hora a vari√°vel vai ser char, outra hora int, outra hora numchar‚Ä¶?
Cria√ß√£o de vari√°veis com base no DDIC
Deixa eu te contar uma coisa sobre o m√©todo ‚Äú
describe_by_name
‚Äú: sabia que ele √© o suficiente para voc√™ ter uma refer√™ncia real de uma vari√°vel do DDIC?
Ele n√£o serve s√≥ para inspe√ß√£o n√£o!
(os exemplos da
parte 2
ficaram muito mais interessantes agora, certo? üôÇ )
No caso da cria√ß√£o com base no DDIC, precisamos primeiro
descrever
um elemento de dados numa das classes do RTTS. Por este motivo, utilizamos a class CL_ABAP_DATADESCR e o m√©todo ‚Äú
describe_by_name
‚Äù para referenciar um elemento de dados do DDIC. Depois √© s√≥ fazer o CREATE DATA..TYPE HANDLE e o ASSIGN para utilizar a vari√°vel.
Simples assim!
DATA: datadescr TYPE REF TO cl_abap_datadescr.
DATA: variavel  TYPE REF TO data.

FIELD-SYMBOLS: <variavel> TYPE any.

* Pelo describe_by_name, conseguimos mostar qual elemento de dados
* o RTTS deve usar de refer√™ncia para instanciar o objeto.
datadescr ?= cl_abap_datadescr=>describe_by_name( 'MATNR' ).

* Depois utilizamos o mesmo esquema para conseguir passar valor
* para a vari√°vel
CREATE DATA variavel TYPE HANDLE datadescr.
ASSIGN variavel->* TO <variavel>.

* Se a exit de convers√£o estiver ativa, voc√™ ver√° o output
* desse valor sem os zeros, afinal, o campo √© um MATNR!
<variavel> = '000000000012345678'.
WRITE <variavel>.
Agora, pegue o exemplo da m√°quina de criar vari√°veis e aplique no exemplo do DDIC. Ser√° que √© poss√≠vel? Ser√° que d√° para fazer outras coisas doidas aliando o RTTS e m√©todos/form ? üòâ
Mas Mauricio, eu s√≥ tenho o nome ‚Äútabela-campo‚Äù, como que eu vou fazer para criar uma vari√°vel com base no DDIC s√≥ com o campo da tabelaaaaaaaa??????
Pera√≠‚Ä¶ voc√™ tem a
TABELA
e o
CAMPO
? Ent√£o √© s√≥ descobrir se ele faz refer√™ncia ao DDIC ou a um tipo p≈ïe-definido (quando voc√™ coloca o tipo direto na SE11), e criar o campo utilizando as classes RTTS que j√° estudamos. O que? ¬†Voc√™ quer saber como descobrir essas coisas?
P√¥ zumbi, usa o google, t√° achando que a vida √© f√°cil? üôÑ üòà Zueira, est√°
aqui o link
.
Cria√ß√£o de Estruturas
J√° vimos anteriormente que as classes do RTTS possuem uma sinergia que atinge
mais de 9000
. Ent√£o, n√£o √© surpresa nenhuma descobrir que para criar uma estrutura com RTTS, voc√™ primeiro precisa criar os campos indivudalmente, para s√≥ ent√£o organiz√°-los em uma estrutura com a classe CL_ABAP_STRUCTDESCR.
No exemplo abaixo criamos uma estrutura com dois campos, um inteiro e um campo do DDIC:
DATA: estrutura TYPE REF TO data.

FIELD-SYMBOLS: <estrutura> TYPE any,
               <campo>     TYPE any.

DATA: structdescr TYPE REF TO cl_abap_structdescr.

* O get da CL_ABAP_STRUCTDESCR tem um param√™tro chamado "P_COMPONENTS".
* N√£o precisa ser nenhum PhD para entender o que precisamos fazer..
DATA: componentes TYPE abap_component_tab,
      componente  LIKE LINE OF componentes.

* A import√¢ncia de entender o RTTS por "etapas" como estamos fazendo
* vem agora. A estrutura de componentes tem um campo chamado "TYPE", que
* aceita um objeto do tipo CL_ABAP_DATADESCR. N√≥s j√° aprendemos como
* criar objetos que fazem refer√™ncia a vari√°veis, certo? Ent√£o vamos
* montar nossa estrutura!

DATA: datadescr TYPE REF TO cl_abap_datadescr,
      elemdescr TYPE REF TO cl_abap_elemdescr.

* Criando um campo CHAR de 10
elemdescr = cl_abap_elemdescr=>get_c( 10 ).
componente-name = 'CHAR_DE_10'.
componente-type = elemdescr.
APPEND componente TO componentes.

* Criando um campo para a planta, com o elemento de dados WERKS_D
datadescr ?= cl_abap_datadescr=>describe_by_name('WERKS_D').
componente-name = 'WERKS'.
componente-type = datadescr.
APPEND componente TO componentes.

* Agora vamos criar nossa estrutura!
structdescr = cl_abap_structdescr=>get( componentes ).

* Mesmo esquema de sempre para poder acess√°-la
CREATE DATA estrutura TYPE HANDLE structdescr.
ASSIGN estrutura->* TO <estrutura>.

* Porem para acessar os campos e preenche-los, vamos utilizar o
* ASSIGN COMPONENT utilizando um √≠ndice para indicar qual o campo
* que queremos acessar
ASSIGN COMPONENT 1 OF STRUCTURE <estrutura> TO <campo>.
<campo> = '1234567890'.

ASSIGN COMPONENT 2 OF STRUCTURE <estrutura> TO <campo>.
<campo> = '3000'.

* Pare aqui no debug e veja os valores preenchidos em <estrutura> :)
BREAK-POINT.
E est√° pronta a nossa estrutura criada dinamicamente. Se voc√™ n√£o conhecia o ASSIGN COMPONENT, leia
este post
aqui do blog onde dissecamos o comando ASSIGN.
Vamos em frente: primeiro voc√™ cria alguns campos, depois cria a estrutura utilizando os campos, e depois‚Ä¶
Cria√ß√£o de Tabelas Internas
Agora √© s√≥ pegar a estrutura do exemplo acima e utiliz√°-la para criar uma tabela interna! Este exemplo serve tamb√©m como uma
sumariza√ß√£o de tudo que aprendemos
sobre cria√ß√£o de vari√°veis neste post.
Se voc√™ s√≥ sabia criar tabela interna com aquele m√©todo do ALV, saiba que √© muito mais legal¬†quando a gente entende o que acontece l√° dentro.
Este exemplo tamb√©m cobre o preenchimento da tabela criada din√¢micamente, afinal, para que serve uma tabela interna se eu n√£o souber como preench√™-la? üôÇ
Divirta-se!
DATA: tabela    TYPE REF TO data,
      estrutura TYPE REF TO data.

FIELD-SYMBOLS: <tabela>    TYPE standard table,
               <estrutura> TYPE any,
               <campo>     TYPE any.

DATA: structdescr TYPE REF TO cl_abap_structdescr,
      tabledescr  TYPE REF TO cl_abap_tabledescr,
      datadescr TYPE REF TO cl_abap_datadescr,
      elemdescr TYPE REF TO cl_abap_elemdescr.

DATA: componentes TYPE abap_component_tab,
      componente  LIKE LINE OF componentes.

*-- Cria√ß√£o da Estrutura Igual Exemplo Anterior:

elemdescr = cl_abap_elemdescr=>get_c( 10 ).
componente-name = 'CHAR_DE_10'.
componente-type = elemdescr.
APPEND componente TO componentes.

datadescr ?= cl_abap_datadescr=>describe_by_name('WERKS_D').
componente-name = 'WERKS'.
componente-type = datadescr.
APPEND componente TO componentes.

* Agora vamos criar nossa estrutura!
structdescr = cl_abap_structdescr=>get( componentes ).

* Mesmo esquema de sempre para poder acess√°-la
CREATE DATA estrutura TYPE HANDLE structdescr.
ASSIGN estrutura->* TO <estrutura>.


*-- Cria√ß√£o da Tabela

* Ok, vamos criar essa tabela bunita. √â claro que vamos utilizar o GET da
* clase CL_ABAP_TABLEDESCR. Notou que tudo no RTTS segue o mesmo padr√£o
* de funcionamento?

* O par√¢metro obrigat√≥rio se chama P_LINE_TYPE. Podemos passar nossa estrutura!
tabledescr ?= cl_abap_tabledescr=>get( structdescr ).

CREATE DATA tabela TYPE HANDLE tabledescr.
ASSIGN tabela->* TO <tabela>.

* Voc√™ ainda pode dizer qual o tipo da tabela (SORTED, HASHED, STANDARD) e quais
* os campos chaves da sua tabela interna. Experimente fu√ßar no m√©todo "get".



*-- Preenchendo a tabela criada din√¢micamente

* Neste caso, eu coloquei o field-symbol como TYPE STANDARD TABLE. Isso me permite
* dar um APPEND da estrutura  pois eu criei a tabela interna da
*  forma default (que √© STANDARD TABLE).

* Primeiro preechemos a estrutura:
ASSIGN COMPONENT 1 OF STRUCTURE <estrutura> TO <campo>.
<campo> = 'MATERIAL123'.

ASSIGN COMPONENT 2 OF STRUCTURE <estrutura> TO <campo>.
<campo> = 'SP01'.

* Depois √© s√≥ dar o append!
APPEND <estrutura> TO <tabela>.

* Pare aqui no debug e veja a tabela criada de forma totalmente din√¢mica, j√°
* preenchida com uma linha! :)
BREAK-POINT.
Voc√™ ainda pode utilizar a tabela interna criada para jogar os dados de um SELECT. √â uma tabela interna e voc√™ pode fazer o que quiser com ela!
Muita gente procura na internet como criar tabelas din√¢micas, caem nos exemplos do RTTS e ficam sem entender absolutamente nada. Mas fala√≠: quando voc√™ entende a sequ√™ncia de cria√ß√£o e a l√≥gica da hierarquia de classes, fica bem mais f√°cil.
E a√≠, tem mais?
Sim, tem muito mais. Minha inten√ß√£o √© que esta sequ√™ncia de posts consiga lhe mostrar a import√¢ncia de compreender o RTTS para ser capaz de criar aplica√ß√µes que fazem coisas malucas. (Ou, pelo menos, deixar
aquele
dev com cara de WTF quando olhar o seu programa üòÄ ).
O RTTS pode criar outras coisas al√©m destas explicadas (como inst√¢ncias de classes!).¬†Pesquise na hierarquia RTTS, que descrevemos na
primeira part
e.
Como sugest√£o de estudo para aprimorar os conhecimentos, tente aliar o que aprendeu na parte 2 com a parte 3 para criar uma estrutura a partir de um TYPES declarado no seu programa.
Eu tamb√©m cobri a cria√ß√£o utilizando os
getters
e com base no
describe_by_name,
mas voc√™ ir√° notar que as classes RTTS possuem m√©todos com o prefixo
create.
Descubra lendo o help das classes porque eu ignorei a cria√ß√£o com os
creates
.
Se voc√™ tiver alguma experi√™ncia legal com RTTS e quiser compartilhar, comente! Aproveite este espa√ßo deixar registrado a sua sugest√£o de uso para os seus camaradas zumbis.
Baixe todos os exemplos
Acesse a p√°gina do ABAPZombie
no Github para baixar todos os exemplos desta sequencia de posts.
Sempre que voc√™ precisar de um c√≥digo aqui do site, acesse o link ‚ÄúC√≥digos ABAPZombie‚Äù no menu lateral. Fique a vontade para nos enviar corre√ß√µes direto no reposit√≥rio do Github!
Acaboooooou!
Foram 3 semanas, muito c√≥digo, muitas siglas e muitas piadas idiotas‚Ä¶ mas chegamos ao fim! Se voc√™ gostou, compartilhe via facebook, twitter, google plus, telefone, sms, sinal de fuma√ßa, grite para o amigo do lado, pombo correio ‚Äì qualquer jeito ajuda.
Abra√ßos a todos aqueles que gostaram de sequ√™ncia mas n√£o entenderam a piada do t√≠tulo üôÅ



Coment√°rios:
Daniel Jesus (28/05/2014 09:19): RTTS √© mara! D√° um trabalhinho pra pensar e organizar no inicio ( assim como qq coisa com OO ), mas depois fica supimpa. Precisei uma vez criar relatorios dinamicos para calculo de deprecia√ß√£o‚Ä¶.o funcional at√© hoje me ama ! ( coisa rara no mundo ABAP )
Henrique Dias (07/05/2014 18:02): Muito boa a s√©rie. Por acaso eu fiz uma classe louca que da um submit num programa que gera um alv que busca as informa√ß√µes desse alv com uma classe maluca que retorna uma tabela dinamica que tem que ser identificada usando essas classes doidonas para transformar isso em alguma coisa que a classe inicial pudesse usar. Quem sabe um dia eu transformo isso num exemplo bacana pra postar. Abra√ßos a todos que n√£o entenderam nada na frase sem pontua√ß√£o
  Mauricio Cruz (07/05/2014 19:12): Valeu manolo que bom que voce gostou espero que voce possa ajustar essa parada ae que voce criou para compartilhar com os seus amiguinhos eu acho que entendi o que voce fez mas talvez nao tenha entendido danem se os pontos virgulas e etcs abs
  Mauricio Cruz (07/05/2014 19:12): Valeu manolo que bom que voce gostou espero que voce possa ajustar essa parada ae que voce criou para compartilhar com os seus amiguinhos eu acho que entendi o que voce fez mas talvez nao tenha entendido danem se os pontos virgulas e etcs abs