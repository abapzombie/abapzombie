Chat Zumbizade‚Ñ¢ com ABAP Channels e UI5
Autor: Leo Schmidt
Data: 03/01/2018 10:00

Fala zumbizada!
Saindo da tumba ap√≥s eras de profundo adormecimento, c√° estou eu de volta √† linha de frente zumbi pra despejar um pouco mais de conhecimento para n√≥s, seres meio-viventes. Dessa vez, vim pra mostrar um exemplo l√∫dico de algo que comentei no
√∫ltimo epis√≥dio do nosso cast
(que sim, saiu ano passado, por√©m n√£o se desesperem pois novo
s
epis√≥dio
s
est√£o a caminho- sim, com S): uma aplica√ß√£ozinha
chat
feita com ABAP Channel e UI5.
Pra quem n√£o sabe,
ABAP Channel
√© a implementa√ß√£o ABAP de
web sockets
. Se voc√™ n√£o entende patavinas deste assunto, recomendo fortemente a leitura do
post
da SAP Community (√© assim que chama agora n√©?) que eu indiquei no The Walking Dev #008 (
eis o link outra vez
).
Web sockets
s√£o coisas bem interessantes, que tem √≥timas possibilidades de aplica√ß√£o dentro do SAP, como por exemplo para a cria√ß√£o de
dashboards real-time
,¬†clientes de
workflow
, ferramentas de coopera√ß√£o, etc.
A ideia desse exemplo √© construir um
chat
simples com uma sala √∫nica pra todos os usu√°rios logados em um mesmo sistema. Cada usu√°rio entra com o pr√≥prio ID na sala e um avatar escolhido aleatoriamente dentre os √≠cones dispon√≠veis no UI5. As mensagens s√£o exibidas com o
timestamp
gerado pelo servidor.
Maur√≠cio fala reservadamente para todos: oi e vc
Vamos aos objetos:
Push channel
Esse nome de classe escroto foi gerado automaticamente blz?
Aqui n√£o tem nada de complicado, basta dar um nome pra sua aplica√ß√£o e uma descri√ß√£o e clicar ali em
Generate Class and Service
. Salvar e ativar, como sempre.
Message channel
Dei o mesmo nome pro message channel por motivos de pregui√ßa
O
message channel
tamb√©m √© bem simples: s√≥ tem um canal,
/chat
, que vai ser do tipo
TEXT
e com escopo
S
(
System
). A√≠ adicionamos a classe gerada pro
push channel
na lista de programas autorizados para as atividades
C
(receber dados por
push channel
) e
S
(enviar). Novamente, salvar e ativar.
Implementa√ß√£o da classe
Private section
private section.

  types: begin of LTY_CONNECTED_USER,
           id TYPE syuname,
           avatar TYPE i,
         end of LTY_CONNECTED_USER.

  methods SEND_MESSAGE
    importing
      !IM_EXTENSION_ID type AMC_CHANNEL_EXTENSION_ID
      !IM_ROOT_ID type ABAP_TRANS_SRCNAME
      !IM_DATA type ANY .
Aqui temos um tipo pra criar uma tabela de usu√°rios conectados no
chat
, e a declara√ß√£o do m√©todo que vai ser usado para enviar mensagens.
IF_APC_WSP_EXTENSION~ON_START
METHOD if_apc_wsp_extension~on_start.

  DATA lt_users TYPE SORTED TABLE OF lty_connected_user WITH UNIQUE KEY id.

  TRY.
      i_context->get_binding_manager( )->bind_amc_message_consumer(
          i_application_id       = 'ZCHAT'
          i_channel_id           = '/chat'
          i_channel_extension_id = '/users'
      ).
      i_context->get_binding_manager( )->bind_amc_message_consumer(
          i_application_id       = 'ZCHAT'
          i_channel_id           = '/chat'
          i_channel_extension_id = '/messages'
      ).
      DATA(lv_avatar) = i_context->get_initial_request( )->get_form_field( 'avatar' ).
    CATCH cx_apc_error INTO DATA(lx_apc_error).
      MESSAGE lx_apc_error->get_text( ) TYPE 'E'.
  ENDTRY.

  IMPORT users = lt_users FROM DATABASE indx(zc) ID 'ZCHAT'.
  READ TABLE lt_users ASSIGNING FIELD-SYMBOL(<user>) WITH KEY id = sy-uname.
  IF sy-subrc = 0.
    <user>-avatar = lv_avatar.
  ELSE.
    INSERT VALUE lty_connected_user( id = sy-uname avatar = lv_avatar ) INTO lt_users INDEX sy-tabix.
  ENDIF.
  EXPORT users = lt_users TO DATABASE indx(zc) ID 'ZCHAT'.

  me->send_message(
      im_extension_id = '/users'
      im_root_id      = 'connectedUsers'
      im_data         = lt_users
  ).

ENDMETHOD.
Esse m√©todo √© chamado assim que a conex√£o do
web socket
√© iniciada.
Na primeira parte, fazemos o
binding
do
push channel
com o
message channel
, criando duas extens√µes diferentes:
/users
, onde v√£o trafegar as mensagens sobre conex√£o e desconex√£o de usu√°rios, e
/messages
, onde v√£o trafegar as mensagens do
chat
em si. Esse recurso das extens√µes √© muito bacana, porque permite segmentar as mensagens sem ter que criar canais diferentes na mesma aplica√ß√£o.
Quando a conex√£o √© criada, a aplica√ß√£o UI5 vai chamar o servi√ßo passando um par√¢metro de URL chamado
avatar
, que vai conter o ID do avatar gerado aleatoriamente pelo
frontend
(porque √© l√° que fica a cole√ß√£o de √≠cones). Juntamos esse valor com o nome do usu√°rio e gravamos a tabela toda num cluster na INDX (tomando cuidado pra ver se o usu√°rio j√° est√° logado). Achei mais simples usar
EXPORT ‚Ä¶ TO DATABASE
nesse caso, mas num caso normal talvez seria melhor usar
shared memory
.
Por fim, enviamos na extens√£o
/users
uma mensagem com a tabela atualizada de usu√°rios conectados.
IF_APC_WSP_EXTENSION~ON_MESSAGE
METHOD if_apc_wsp_extension~on_message.

  DATA: BEGIN OF ls_message,
          text      TYPE string,
          sender    TYPE string,
          timestamp TYPE string,
        END OF ls_message.

  TRY.
      ls_message-text = i_message->get_text( ).
    CATCH cx_apc_error INTO DATA(lx_apc_error).
      MESSAGE lx_apc_error->get_text( ) TYPE 'E'.
  ENDTRY.

  ls_message-sender = sy-uname.
  GET TIME STAMP FIELD DATA(lv_timestamp).
  ls_message-timestamp = |{ lv_timestamp TIMESTAMP = ISO TIMEZONE = sy-zonlo }|.

  me->send_message(
      im_extension_id = '/messages'
      im_root_id      = 'message'
      im_data         = ls_message
  ).

ENDMETHOD.
Esse m√©todo √© chamado toda vez que o
push
channel
recebe uma mensagem ‚Äì no nosso caso, √© sempre uma mensagem do
chat
. Portanto, √© uma implementa√ß√£o bem simples: pegamos o texto, marcamos com o ID do usu√°rio e o
timestamp
formatado como ISO no fuso local, e retornamos na extens√£o
/messages
.
IF_APC_WSP_EXTENSION~ON_CLOSE
METHOD if_apc_wsp_extension~on_close.

  DATA lt_users TYPE SORTED TABLE OF lty_connected_user WITH UNIQUE KEY id.

  IMPORT users = lt_users FROM DATABASE indx(zc) ID 'ZCHAT'.
  DELETE lt_users WHERE id = sy-uname.
  IF lines( lt_users ) = 0.
    DELETE FROM DATABASE indx(zc) ID 'ZCHAT'.
  ELSE.
    EXPORT users = lt_users TO DATABASE indx(zc) ID 'ZCHAT'.
  ENDIF.

  me->send_message(
      im_extension_id = '/users'
      im_root_id      = 'connectedUsers'
      im_data         = lt_users
  ).

ENDMETHOD.
Esse m√©todo √© chamado ao encerrar a conex√£o. Aqui, precisamos notificar todos que houve uma desconex√£o, ent√£o verificamos a tabela de usu√°rios e removemos o ID que desconectou, tomando o cuidado de zerar a tabela do
cluster
na INDX quando n√£o houver mais ningu√©m no
chat
. A tabela final √© enviada na extens√£o
/users
.
SEND_MESSAGE
METHOD send_message.

  DATA: lo_producer TYPE REF TO if_amc_message_producer_text,
        lv_key      TYPE        string.

  DATA(lt_source) = VALUE abap_trans_srcbind_tab( ( name = im_root_id value = REF #( im_data ) ) ).
  DATA(lo_writer) = cl_sxml_string_writer=>create( type = if_sxml=>co_xt_json ).
  CALL TRANSFORMATION id SOURCE (lt_source) RESULT XML lo_writer.
  DATA(lv_message) = cl_abap_codepage=>convert_from( lo_writer->get_output( ) ).
  DO.
    CLEAR lv_key.
    lv_key = match( val = lv_message regex = '"[0-9_\-]*[A-Z]+[A-Z0-9_\-]*":' ).
    IF lv_key IS INITIAL.
      EXIT.
    ELSE.
      REPLACE ALL OCCURRENCES OF lv_key IN lv_message WITH to_lower( lv_key ).
    ENDIF.
  ENDDO.

  TRY.
      lo_producer ?= cl_amc_channel_manager=>create_message_producer(
          i_application_id       = 'ZCHAT'
          i_channel_id           = '/chat'
          i_channel_extension_id = im_extension_id
      ).
      lo_producer->send( lv_message ).
    CATCH cx_amc_error INTO DATA(lx_amc_error).
      MESSAGE lx_amc_error->get_text( ) TYPE 'E'.
  ENDTRY.

ENDMETHOD.
Esse √© um m√©todo utilit√°rio para enviar mensagens pelo
message channel
. Basicamente, pegamos os dados que precisam ser enviados (em qualquer formato que estejam: vari√°vel simples, estrutura, tabela, etc.), chamamos o
CALL TRANSFORMATION id
para gerar uma sa√≠da JSON atrav√©s da
CL_SXML_STRING_WRITER
, e atrav√©s de uma express√£o regular deixamos todos os identificadores do JSON em min√∫sculas.
Por fim, criamos um
message producer
com a extens√£o necess√°ria e enviamos a mensagem.
UI5
Chat.view.xml
<mvc:View controllerName="com.abapzombie.chat.controller.Chat" xmlns:html="http://www.w3.org/1999/xhtml" xmlns:mvc="sap.ui.core.mvc" displayBlock="true" xmlns="sap.m">
  <App>
    <pages>
      <Page id="chatWindow" class="sapUiContentPadding" title="{i18n>title}">
        <subHeader>
          <Toolbar>
            <Label design="Bold" text="{i18n>usersLabel}"/>
            <Tokenizer tokens="{ path: 'user>/connectedUsers', sorter: 'id' }">
              <Token key="{user>id}" text="{user>id}" editable="false"/>
            </Tokenizer>
          </Toolbar>
        </subHeader>
        <footer>
          <Toolbar>
            <Input id="message" placeholder="{i18n>messagePlaceholder}" change="onSend"/>
            <Button type="Emphasized" icon="sap-icon://paper-plane" press="onSend"/>
          </Toolbar>
        </footer>
      </Page>
    </pages>
  </App>
</mvc:View>
Chat.controller.js
sap.ui.define([
  "sap/ui/core/mvc/Controller",
  "sap/ui/model/json/JSONModel",
  "sap/m/FeedListItem"
], function(Controller, JSONModel, FeedListItem) {
  "use strict";

  return Controller.extend("com.abapzombie.chat.controller.Chat", {

    onInit: function() {
      this.getView().setModel(new JSONModel({
        connectedUsers: []
      }), "user");
      this._setChatWindowScroll();
      this._setMessageInputKeydown();
      this._setWebSocket();
    },

    onSend: function() {
      var oMessageInput = this.byId("message"),
          sText = oMessageInput.getValue();
      if (sText) {
        this._wsChat.send(sText);
      }
      oMessageInput.setValue("");
    },

    onExit: function() {
      this._wsChat.close();
    },

    _getAvatar: function(sSender) {
      var aConnectedUsers = this.getView().getModel("user").getProperty("/connectedUsers"),
          aSender = jQuery.grep(aConnectedUsers, function(user) {
            return user.id === sSender;
          });
      if (aSender.length === 1) {
        return "sap-icon://" + sap.ui.core.IconPool.getIconNames()[aSender[0].avatar];
      }
    },

    _setMessageInputKeydown: function() {
      this.byId("message").attachBrowserEvent("keydown", function(oEvent) {
        if (oEvent.which === 9) {
          oEvent.preventDefault();
        }
      });
    },

    _setChatWindowScroll: function() {
      var oChatWindow = this.byId("chatWindow");
      oChatWindow.addEventDelegate({
        onAfterRendering: function() {
          var aContent = oChatWindow.getContent();
          if (aContent.length > 0) {
            var $lastItem = jQuery.sap.byId(aContent.pop().sId);
            oChatWindow.scrollTo($lastItem.position().top + $lastItem.outerHeight());
          }
        }
      }, this);
    },

    _setWebSocket: function() {
      var sWSURL = "ws://" + window.location.host + "/sap/bc/apc/sap/zchat?" + jQuery.param({
            avatar: Math.floor(Math.random() * sap.ui.core.IconPool.getIconNames().length)
          }),
          oUserModel = this.getView().getModel("user"),
          oChatWindow = this.byId("chatWindow"),
          that = this;
      this._wsChat = new WebSocket(sWSURL);
      this._wsChat.addEventListener("message", function(oEvent) {
        var oData = JSON.parse(oEvent.data);
        if (oData.connectedUsers) {
          oUserModel.setProperty("/connectedUsers", oData.connectedUsers);
        }
        if (oData.message) {
          oChatWindow.addContent(new FeedListItem({
            icon: that._getAvatar(oData.message.sender),
            iconActive: false,
            sender: oData.message.sender,
            senderActive: false,
            text: oData.message.text,
            timestamp: (new Date(oData.message.timestamp)).toLocaleString()
          }));
        }
      });
    }

  });

});
Tanto a
view
quanto o
controller
s√£o bem simples.
A
view
consiste em uma p√°gina com o¬†conte√∫do principal vazio, que √© onde v√£o aparecer as mensagens assim que elas forem recebidas. O conte√∫do fixo s√£o duas
toolbars
, uma no topo com um
tokenizer
para exibir os usu√°rios conectados e outra na parte de baixo com o
input
e o bot√£o para enviar mensagens.
O
controller
tem as seguintes atribui√ß√µes:
Criar um
JSONModel
para alimentar o
tokenizer
(feito diretamente no
onInit
);
Definir o
scroll
autom√°tico da p√°gina, para quando novas mensagens forem adicionadas (m√©todo
_setChatWindowScroll
);
Impedir o uso de [Tab] no
input
, para que somente o [Enter] envie mensagens (m√©todo
_setMessageInputKeydown
);
Configurar o
web socket
(finalmente! pelo m√©todo
_setWebSocket
), onde:
Define-se um avatar aleat√≥rio, pelo √≠ndice do
IconPool
;
Abre-se a conex√£o com o
web socket
;
Define-se um
event handler
para quando chegarem mensagens:
Se houver o identificador
connectedUsers
, definir o conte√∫do dentro do
JSONModel
;
Se houver o identificador
message
, criar um novo
FeedListItem
com os dados da mensagem;
Enviar a mensagem (m√©todo
onSend
);
E fechar a conex√£o com o
web socket
(diretamente no m√©todo
onExit
).
E √© basicamente isso. Agora, caro amigo zumbi, vc tem um chat pra conversar com os seus outros amiguinhos zumbis no projeto.
Nas vers√µes mais novas do UI5 j√° existe a classe
sap.ui.core.ws.WebSocket
, ent√£o se voc√™ estiver surfando na crista da onda j√° d√° pra usar ela em vez da classe JS pura que eu usei aqui.
D√∫vidas, sugest√µes ou coment√°rios? S√≥ postar que a gente se fala.
PS.:
Nada disso est√° no Github por motivos de pregui√ßa üôÅ
Mentira!
T√° l√° no Github sim
üôÇ



Coment√°rios:
Anderson (21/06/2019 16:40): tem que colocar alguma coisa no neo-app.json? existe alguma configura√ß√£o adicional no destination la no SCP ? i need it!!!
  Leo Schmidt (21/06/2019 17:18): Fala Anderson, blz? Pelo que eu entendi, vc t√° desenvolvendo no SCP Trial e usando uma destination via Cloud Connector. Nesse caso, teu neo-app.json tem que apontar os recursos pra destination, sen√£o vc vai usar os recursos locais do SCP. Algo do tipo: { "path": "/destinations/northwind", "target": { "type": "destination", //tem que indicar essa propriedade aqui "name": "northwind" //aqui vc usa o nome da sua destination }, "description": "Northwind OData Service" } N√£o tentei ainda usar uma configura√ß√£o desse tipo nesse projeto, n√£o sei se funcionaria por causa do caminho do ABAP Channel ( ws:// ). Quando tiver um tempo, posso tentar aqui e ver se funciona. Abra√ßo!
    Anderson (21/06/2019 17:37): Grande Leo!! isso a√≠‚Ä¶ esse √© o cen√°rio‚Ä¶ o desafio √© justamente esse, passar pelo cloud connector do SCP .. Pensei at√© que seu exemplo fosse desse jeito‚Ä¶ Ficarei grato se conseguir dessa forma e compartilhar aqui. Encontrei uma nota onde diz que o CloudConnector tem que ser na vers√£o 2.12 (a ultima) ‚Ä¶ fiz algo pareciso com a defini√ß√£o do destination que vc mencionou, por√©m sem sucesso‚Ä¶ Ainda estou aqui na luta. De qquer forma se eu conseguir volto aqui e compartilho.. Obrigado!
    Anderson (21/06/2019 17:37): Grande Leo!! isso a√≠‚Ä¶ esse √© o cen√°rio‚Ä¶ o desafio √© justamente esse, passar pelo cloud connector do SCP .. Pensei at√© que seu exemplo fosse desse jeito‚Ä¶ Ficarei grato se conseguir dessa forma e compartilhar aqui. Encontrei uma nota onde diz que o CloudConnector tem que ser na vers√£o 2.12 (a ultima) ‚Ä¶ fiz algo pareciso com a defini√ß√£o do destination que vc mencionou, por√©m sem sucesso‚Ä¶ Ainda estou aqui na luta. De qquer forma se eu conseguir volto aqui e compartilho.. Obrigado!
  Leo Schmidt (21/06/2019 17:18): Fala Anderson, blz? Pelo que eu entendi, vc t√° desenvolvendo no SCP Trial e usando uma destination via Cloud Connector. Nesse caso, teu neo-app.json tem que apontar os recursos pra destination, sen√£o vc vai usar os recursos locais do SCP. Algo do tipo: { "path": "/destinations/northwind", "target": { "type": "destination", //tem que indicar essa propriedade aqui "name": "northwind" //aqui vc usa o nome da sua destination }, "description": "Northwind OData Service" } N√£o tentei ainda usar uma configura√ß√£o desse tipo nesse projeto, n√£o sei se funcionaria por causa do caminho do ABAP Channel ( ws:// ). Quando tiver um tempo, posso tentar aqui e ver se funciona. Abra√ßo!
    Anderson (21/06/2019 17:37): Grande Leo!! isso a√≠‚Ä¶ esse √© o cen√°rio‚Ä¶ o desafio √© justamente esse, passar pelo cloud connector do SCP .. Pensei at√© que seu exemplo fosse desse jeito‚Ä¶ Ficarei grato se conseguir dessa forma e compartilhar aqui. Encontrei uma nota onde diz que o CloudConnector tem que ser na vers√£o 2.12 (a ultima) ‚Ä¶ fiz algo pareciso com a defini√ß√£o do destination que vc mencionou, por√©m sem sucesso‚Ä¶ Ainda estou aqui na luta. De qquer forma se eu conseguir volto aqui e compartilho.. Obrigado!
    Anderson (21/06/2019 17:37): Grande Leo!! isso a√≠‚Ä¶ esse √© o cen√°rio‚Ä¶ o desafio √© justamente esse, passar pelo cloud connector do SCP .. Pensei at√© que seu exemplo fosse desse jeito‚Ä¶ Ficarei grato se conseguir dessa forma e compartilhar aqui. Encontrei uma nota onde diz que o CloudConnector tem que ser na vers√£o 2.12 (a ultima) ‚Ä¶ fiz algo pareciso com a defini√ß√£o do destination que vc mencionou, por√©m sem sucesso‚Ä¶ Ainda estou aqui na luta. De qquer forma se eu conseguir volto aqui e compartilho.. Obrigado!
Anderson (21/06/2019 10:13): amigo.. do lado SAP tudo ok.. mas n√£o consigo fazer funcionar no ui5 de jeito nenhum‚Ä¶ ja passei pelo erro http 404, 405, tentei algumas alternativas de link e nada‚Ä¶ Acredito que meu problema seja na montagem correta do link para acessar o connector do scp.. eu n√£o teria que cadastrar algo no meu neo-app.json? ajuda ai please!!!
Richard (08/01/2018 14:40): Legal ver novos posts por aqui! No aguardo do podcast üòÄ